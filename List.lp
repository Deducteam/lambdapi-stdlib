require open Stdlib.Set Stdlib.Logic Stdlib.Nat

// Type of polymorphic lists

constant symbol list : Set â†’ Set

set declared "ğ•ƒ"

definition ğ•ƒa â‰” Ï„ (list a)

set declared "â–¡"

constant symbol â–¡ {a} : ğ•ƒa
constant symbol cons {a} : Ï„a â†’ ğ•ƒa â†’ ğ•ƒa

set infix 4 "â¸¬" â‰” cons

// Induction principle on lists

symbol list_ind {a} (p:ğ•ƒaâ†’Prop) :
  Ï€(p â–¡) â†’ (Î x l,Ï€(p l) â†’ Ï€(p(xâ¸¬l))) â†’ Î l,Ï€(p l)

// Length of a list

symbol length {a} : ğ•ƒa â†’ â„•

rule length â–¡ â†ª 0
with length (_ â¸¬ $l) â†ª suc (length $l)

// Concatenation of two lists

symbol concat {a} : ğ•ƒa â†’ ğ•ƒa â†’ ğ•ƒa

set infix right 5 "â‹…" â‰” concat

assert a (x y z:ğ•ƒa) âŠ¢ xâ‹…yâ‹…z â‰¡ xâ‹…(yâ‹…z)
assert a x l m âŠ¢ xâ¸¬lâ‹…m â‰¡ xâ¸¬(lâ‹…m)

rule â–¡ â‹… $m â†ª $m
with ($x â¸¬ $l) â‹… $m â†ª $x â¸¬ ($l â‹… $m)

theorem concat_nil {a} (l:ğ•ƒa) : Ï€(l â‹… â–¡ = l)
proof
  assume a
  refine list_ind _ _ _
  // case l = â–¡
  reflexivity
  // case l = x â¸¬ l'
  assume x l' h
  simpl
  rewrite h
  reflexivity
qed

rule $m â‹… â–¡ â†ª $m

theorem length_concat {a} (l m : ğ•ƒa) :
  Ï€(length (l â‹… m) = length l + length m)
proof
  assume a
  refine list_ind _ _ _
  // case l = â–¡
  assume m
  reflexivity
  // case l = xâ¸¬l'
  assume x l' h m
  simpl
  rewrite h
  reflexivity
qed

rule length ($l â‹… $m) â†ª length $l + length $m

theorem concat_assoc {a} (l m n : ğ•ƒa) : Ï€((l â‹… m) â‹… n = l â‹… (m â‹… n))
proof
  assume a
  refine list_ind _ _ _
  // case l = â–¡
  assume m n
  reflexivity
  // case l = xâ¸¬l'
  assume x l' h m n
  simpl
  rewrite h
  reflexivity
qed

rule ($l â‹… $m) â‹… $n â†ª $l â‹… ($m â‹… $n)
