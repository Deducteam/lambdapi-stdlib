// Polymorphic lists

/*
 * Lemmas with incomplete proofs :
 * size_take, rotK, rot_inj, eq_find, filter_undup, count_undup
 * Lemmas using apply ind_ğ”¹ or ind_B
 * index_size, find_sier, count_size, size_filter, filter_cat, filter_rev, eq_find?, size_undup
 * (ind_B is an induction principle on booleans demonstrated with ind_ind_ğ”¹, it allow to get hypothesis)
 */

require open Blanqui.Lib.Set Blanqui.Lib.Prop Blanqui.Lib.FOL Blanqui.Lib.Eq Blanqui.Lib.Nat Blanqui.Lib.Bool;

// Boolean equality on natural numbers 
symbol â‰Œ : â„• â†’ â„• â†’ ğ”¹;

notation â‰Œ infix 10;

rule 0 â‰Œ 0 â†ª true
with s $x â‰Œ s $y â†ª $x â‰Œ $y
with 0 â‰Œ s _ â†ª false
with s _ â‰Œ 0 â†ª false;

// List's definition
(a:Set) inductive ğ•ƒ:TYPE â‰”
| â–¡ : ğ•ƒ a // \Box
| â¸¬ : Ï„ a â†’ ğ•ƒ a â†’ ğ•ƒ a; // ::

notation â¸¬ infix right 4;

// set code for ğ•ƒ

constant symbol list : Set â†’ Set;

rule Ï„ (list $a) â†ª ğ•ƒ $a;

// Equality on lists
symbol # [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ”¹;

rule # $beq â–¡ â–¡ â†ª true
with # $beq $l â–¡ â†ª false
with # $beq â–¡ $l â†ª false
with # $beq ($x â¸¬ $lx) ($y â¸¬ $ly) â†ª ($beq $x $y) and (# $beq $lx $ly);

// Length of a list
symbol size [a] : ğ•ƒ a â†’ â„•;

rule size â–¡ â†ª 0
with size (_ â¸¬ $l) â†ª s (size $l);

opaque symbol size0nil [a] (l:ğ•ƒ a) : Ï€ (size l = 0) â†’ Ï€ (l = â–¡) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume e l h; simplify; assume i; 
    apply âŠ¥â‚‘;
    apply snâ‰ 0 (size l) i; 
  }
end;

// Empty list
symbol is0b : â„• â†’ ğ”¹;
rule is0b 0 â†ª true
with is0b (s $x) â†ª false;

symbol nilp [a] : ğ•ƒ a â†’ ğ”¹ â‰” Î» l, is0b (size l);

symbol l : ğ•ƒ nat â‰” â–¡;
compute nilp (1 â¸¬ l);

// Concatenation of two lists

symbol â‹… [a] : ğ•ƒ a â†’ ğ•ƒ a â†’ ğ•ƒ a;

notation â‹… infix right 15; // \cdot

assert a (x y z:ğ•ƒ a) âŠ¢ x â‹… y â‹… z â‰¡ x â‹… (y â‹… z);
assert a x l m âŠ¢ x â¸¬ l â‹… m â‰¡ x â¸¬ (l â‹… m);

rule â–¡ â‹… $m â†ª $m
with ($x â¸¬ $l) â‹… $m â†ª $x â¸¬ ($l â‹… $m);

opaque symbol cat0s [a] (l:ğ•ƒ a) : Ï€ (â–¡ â‹… l = l) â‰”
begin
  reflexivity;
end;

opaque symbol cat1s [a] (x:Ï„ a) (l:ğ•ƒ a) : Ï€ ((x â¸¬ â–¡) â‹… l = (x â¸¬ l)) â‰”
begin
  reflexivity;
end;

opaque symbol cat_cons [a] (x:Ï„ a) (l1:ğ•ƒ a) (l2:ğ•ƒ a) : Ï€ ((x â¸¬ l1) â‹… l2 = (x â¸¬ l1) â‹… l2) â‰”
begin
  reflexivity;
end;

// Nseq
symbol nseq [a] : â„• â†’ Ï„ a â†’ ğ•ƒ a; // nseq n x == a sequence of n x's.

rule nseq 0 $x â†ª â–¡
with nseq (s $n) $x â†ª $x â¸¬ (nseq $n $x);

// Ncons
symbol ncons [a] : â„• â†’ Ï„ a â†’ ğ•ƒ a â†’ ğ•ƒ a;  //ncons n x s == a sequence of n x's, followed by s.

rule ncons 0 $x $l â†ª $l
with ncons (s $n) $x $l â†ª $x â¸¬ (ncons $n $x $l);

opaque symbol size_ncons [a] n (x:Ï„ a) (l:ğ•ƒ a) : Ï€ (size (ncons n x l) = n + size l) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume n h x l; simplify; apply feq s (h x l); }
end;

opaque symbol size_nseq [a] n (x:Ï„ a) : Ï€ (size (nseq n x) = n) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume n h x; simplify; apply feq s (h x); }
end;

opaque symbol cat_nseq [a] n (x:Ï„ a) (l:ğ•ƒ a) : Ï€ ((nseq n x) â‹… l = ncons n x l) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume n h x l; simplify; rewrite h x l; reflexivity; }
end;

opaque symbol nseqD [a] n1 n2 (x:Ï„ a) : Ï€ (nseq (n1 + n2) x = (nseq n1 x) â‹… (nseq n2 x)) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume n1 h n2 x; simplify; rewrite h n2; reflexivity; }
end;

opaque symbol cats0 [a] (l:ğ•ƒ a) : Ï€(l â‹… â–¡ = l) â‰”
begin
  assume a; induction
  { reflexivity }
  { assume x l' h; simplify; rewrite h; reflexivity }
end;

rule $m â‹… â–¡ â†ª $m;

opaque symbol size_cat [a] (l m : ğ•ƒ a) : Ï€(size (l â‹… m) = size l + size m) â‰”
begin
  assume a; induction
  { reflexivity }
  { assume x l' h m; simplify; rewrite h; reflexivity }
end;

rule size ($l â‹… $m) â†ª size $l + size $m;

opaque symbol catA  [a] (l m n : ğ•ƒ a) : Ï€((l â‹… m) â‹… n = l â‹… (m â‹… n)) â‰”
begin
  assume a; induction
  { reflexivity }
  { assume x l' h m n; simplify; rewrite h; reflexivity }
end;

rule ($l â‹… $m) â‹… $n â†ª $l â‹… ($m â‹… $n);

opaque symbol cat_nilp [a] (l1 l2 : ğ•ƒ a) : Ï€ (nilp (l1 â‹… l2) = (nilp l1 and nilp l2)) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume e l h l2; simplify; reflexivity; }
end;

// List reversal

symbol rev [a] : ğ•ƒ a â†’ ğ•ƒ a;

rule rev â–¡ â†ª â–¡
with rev ($x â¸¬ $l) â†ª rev $l â‹… ($x â¸¬ â–¡);

opaque symbol rev_concat [a] (l m : ğ•ƒ a) : Ï€(rev (l â‹… m) = rev m â‹… rev l) â‰”
begin
  assume a; induction
  { simplify; reflexivity }
  { assume x l h m; simplify; rewrite h; reflexivity }
end;

rule rev ($l â‹… $m) â†ª rev $m â‹… rev $l;

opaque symbol rev_idem [a] (l :ğ•ƒ a) : Ï€(rev (rev l) = l) â‰”
begin
  assume a; induction
  { reflexivity }
  { assume x l h; simplify; rewrite h; reflexivity }
end;

rule rev (rev $l) â†ª $l;

opaque symbol length_rev [a] (l : ğ•ƒ a) : Ï€(size (rev l) = size l) â‰”
begin
  assume a; induction
  { simplify; reflexivity }
  { assume x l h; simplify; rewrite h; reflexivity }
end;

rule size (rev $l) â†ª size $l;

// Rcons
symbol rcons [a] : ğ•ƒ a â†’ Ï„ a â†’ ğ•ƒ a;

rule rcons â–¡ $x â†ª $x â¸¬ â–¡
with rcons ($e â¸¬ $l) $x â†ª $e â¸¬ (rcons $l $x);

opaque symbol cats1 [a] (l:ğ•ƒ a) (z:Ï„ a) : Ï€ (l â‹… (z â¸¬ â–¡) = rcons l z) â‰”
begin
  assume a; 
  induction
  { reflexivity; }
  { assume e l h z; simplify; rewrite h z; reflexivity; }
end;

opaque symbol rcons_cons [a] (x:Ï„ a) (s:ğ•ƒ a) (z:Ï„ a) : Ï€ ((rcons (x â¸¬ s) z) = (x â¸¬ (rcons s z))) â‰”
begin
  reflexivity;
end;

// Constructors

symbol seqn_type : â„• â†’ Set â†’ TYPE;
rule seqn_type 0 $a â†ª ğ•ƒ $a
with seqn_type (s $n) $a â†ª Ï„ $a â†’ (seqn_type $n $a);

symbol seqn [a] n : seqn_type n a;
symbol seqn' [a] n : ğ•ƒ a â†’ seqn_type n a;

rule @seqn $a $n â†ª @seqn' $a $n â–¡
with @seqn' $a 0 $l â†ª @rev $a $l
with @seqn' $a (s $n) $l $x â†ª @seqn' $a $n ($x â¸¬ $l);

compute seqn 2 1 2;

// isâ–¡
symbol isâ–¡ [a]: ğ•ƒ a â†’ ğ”¹;

rule isâ–¡ â–¡ â†ª true
with isâ–¡ ($e â¸¬ $l) â†ª false;

compute isâ–¡ â–¡;
compute isâ–¡ (3 â‰¤ 5 â¸¬ â–¡);

// Head
symbol head [a] : Ï„ a â†’ ğ•ƒ a â†’ Ï„ a;

rule head $x â–¡ â†ª $x
with head $x ($e â¸¬ $l) â†ª $e;

compute head 3 (5 â¸¬ 7 â¸¬ 6 â¸¬ â–¡);
compute head 3 â–¡;

// Behead
symbol behead [a] : ğ•ƒ a â†’ ğ•ƒ a;

rule behead â–¡ â†ª â–¡
with behead ($x â¸¬ $l) â†ª $l;

compute behead (5 â¸¬ 7 â¸¬ 6 â¸¬ â–¡);

opaque symbol size_behead [a] (l:ğ•ƒ a) : Ï€ (size (behead l) = p (size l)) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume e l h; reflexivity; }
end;

// Last Î» 
symbol last [a] : Ï„ a â†’ ğ•ƒ a â†’ Ï„ a;

rule last $x â–¡ â†ª $x
with last $x ($e â¸¬ $l) â†ª (last $e $l);

compute last 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡);
compute last 4 â–¡;

// Belast
symbol belast [a] : Ï„ a â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule belast $x â–¡ â†ª â–¡
with belast $x ($e â¸¬ $l) â†ª $x â¸¬ (belast $e $l);

compute belast 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡);

// Nth
symbol nth [a] : Ï„ a â†’ ğ•ƒ a â†’ â„• â†’ Ï„ a;

rule nth $x0 â–¡ $i â†ª $x0
with nth $x0 ($e â¸¬ $l) 0 â†ª $e
with nth $x0 ($e â¸¬ $l) (s $n) â†ª (nth $x0 $l $n);

compute nth 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 0;
compute nth 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 2;
compute nth 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 3;
compute nth 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 42;

// set_nth x0 l i y
symbol set_nth [a] : Ï„ a â†’ ğ•ƒ a â†’ â„• â†’ Ï„ a â†’ ğ•ƒ a;

rule set_nth $x0 â–¡ 0 $y â†ª $y â¸¬ â–¡
with set_nth $x0 ($e â¸¬ $l) 0 $y â†ª $y â¸¬ $l
with set_nth $x0 â–¡ (s $i) $y â†ª $x0 â¸¬ (set_nth $x0 â–¡ $i $y)
with set_nth $x0 ($e â¸¬ $l) (s $i) $y â†ª $e â¸¬ (set_nth $x0 $l $i $y);

compute set_nth 42 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 1 6;
compute set_nth 42 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 2 6;
compute set_nth 42 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 5 6;

// incr_nth l i
symbol incr_nth : ğ•ƒ nat â†’ Ï„ nat â†’ ğ•ƒ nat;

rule incr_nth â–¡ 0 â†ª 1 â¸¬ â–¡
with incr_nth â–¡ (s $i) â†ª 0 â¸¬ (incr_nth â–¡ $i)
with incr_nth ($n â¸¬ $l) 0 â†ª (s $n) â¸¬ $l
with incr_nth ($n â¸¬ $l) (s $i) â†ª $n â¸¬ (incr_nth $l $i);

compute incr_nth (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 1;
compute incr_nth (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 2;
compute incr_nth (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 5;

// zip 
// /!\ Drop any extra items
symbol âŠ— : Set â†’ Set â†’ Set;
notation âŠ— infix 10;

symbol ~ [a b] : Ï„ a â†’ Ï„ b â†’ Ï„ (a âŠ— b);
notation ~ infix 10;

symbol zip [a b] : ğ•ƒ a â†’ ğ•ƒ b â†’ ğ•ƒ (a âŠ— b);

rule zip â–¡ â–¡ â†ª â–¡
with zip â–¡ $l â†ª â–¡
with zip $l â–¡ â†ª â–¡
with zip ($e1 â¸¬ $l1) ($e2 â¸¬ $l2) â†ª ($e1 ~ $e2) â¸¬ (zip $l1 $l2);

compute (3 ~ 5) â¸¬ (6 ~ 4) â¸¬ (7 ~ 2) â¸¬ (8 ~ 1) â¸¬ â–¡;
 
symbol unzip1 [a b] : ğ•ƒ (a âŠ— b) â†’ ğ•ƒ a;
rule @unzip1 $a $b (@â–¡ ($a âŠ— $b)) â†ª (@â–¡ $a)
with @unzip1 $a $b (@â¸¬ ($a âŠ— $b) (@~ $a $b $e1 $e2) $l) â†ª (@â¸¬ $a $e1 (@unzip1 $a $b $l));

symbol unzip2 [a b] : ğ•ƒ (a âŠ— b) â†’ ğ•ƒ b;
rule @unzip2 $a $b (@â–¡ ($a âŠ— $b)) â†ª (@â–¡ $b)
with @unzip2 $a $b (@â¸¬ ($a âŠ— $b) (@~ $a $b $e1 $e2) $l) â†ª (@â¸¬ $b $e2 (@unzip2 $a $b $l));

compute @unzip1 nat nat ((3 ~ 5) â¸¬ (6 ~ 4) â¸¬ (7 ~ 2) â¸¬ (8 ~ 1) â¸¬ â–¡);
compute @unzip2 nat nat ((3 ~ 5) â¸¬ (6 ~ 4) â¸¬ (7 ~ 2) â¸¬ (8 ~ 1) â¸¬ â–¡);

symbol all2 [a b] : (Ï„ a â†’ Ï„ b â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ b â†’ ğ”¹;

rule all2 $pr â–¡ â–¡ â†ª true
with all2 $pr ($ea â¸¬ $la) ($eb â¸¬ $lb) â†ª ($pr $ea $eb) and (all2 $pr $la $lb);

/*opaque symbol zip_unzip [a b] (l:ğ•ƒ (a âŠ— b)) : Ï€ (@zip a b (@unzip1 a b l) (@unzip2 a b l) = l) â‰”
begin
  assume a b l;
  apply @ind_ğ•ƒ (a âŠ— b) (Î» ll:ğ•ƒ (a âŠ— b), zip (unzip1 ll) (unzip2 ll) = ll) _ _ l {} {} {} {} {} {} {} {} {} {};
end;*/

opaque symbol unzip1_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) : Ï€ (istrue (size la â‰¤ size lb)) â†’ Ï€ (@unzip1 a b (@zip a b la lb) = la) â‰”
begin
  assume a b;
  induction
  { reflexivity; }
  { assume ea la h;
    induction
    { simplify; assume i; apply âŠ¥â‚‘ _ i; }
    { assume eb lb i; simplify; assume j; apply feq (Î» l:ğ•ƒ a, ea â¸¬ l) (h lb j); }
  }
end;

opaque symbol unzip2_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) : Ï€ (istrue (size lb â‰¤ size la)) â†’ Ï€ (@unzip2 a b (@zip a b la lb) = lb) â‰”
begin
  assume a b;
  induction
  { simplify; assume lb h; have t:Ï€ (size lb = 0) { apply â‰¤0 (size lb) h; }; symmetry; apply size0nil lb t; }
  { assume ea la h;
    induction
    { reflexivity; }
    { assume eb lb i; simplify; assume j; apply feq (Î» l:ğ•ƒ b, eb â¸¬ l) (h lb j); }
  }
end;

opaque symbol size1_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) : Ï€ (istrue (size la â‰¤ size lb)) â†’ Ï€ (size (zip la lb) = size la) â‰”
begin
  assume a b;
  induction
  { reflexivity; }
  { assume ea la h;
    induction
    { simplify; assume i; apply âŠ¥â‚‘ _ i; }
    { assume eb lb i; simplify; assume j; apply feq s (h lb j); }
  }
end;

opaque symbol size2_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) : Ï€ (istrue (size lb â‰¤ size la)) â†’ Ï€ (size (zip la lb) = size lb) â‰”
begin
  assume a b;
  induction
  { assume lb; simplify; assume h; symmetry; apply â‰¤0 (size lb) h; }
  { assume ea la h; 
    induction
    { reflexivity; }
    { assume eb lb i; simplify; assume j; apply feq s (h lb j); }
  }
end;

opaque symbol size_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) : Ï€ (size (zip la lb) = min (size la) (size lb)) â‰”
begin
  assume a b;
  induction
  { reflexivity }
  { assume ea la h;
    induction
    { reflexivity; }
    { assume eb lb i; simplify; apply feq s (h lb); }
  }
end;

//Double induction
opaque symbol seq_ind2 [a b] (P:ğ•ƒ a â†’ ğ•ƒ b â†’ Prop) : Ï€ (P â–¡ â–¡) â†’ (Î  la:ğ•ƒ a, Î  lb:ğ•ƒ b, Î  ea:Ï„ a, Î  eb:Ï„ b, Ï€ (size la = size lb) â†’ Ï€ (P la lb) â†’ Ï€ (P (ea â¸¬ la) (eb â¸¬ lb))) â†’ Î  la:ğ•ƒ a, Î  lb:ğ•ƒ b, Ï€ (size la = size lb) â†’ Ï€ (P la lb) â‰”
begin
  assume a b P P0 PH;
  induction
  { induction
    { assume h; apply P0; }
    { assume eb lb; simplify; assume h1 h2; have t:Ï€ (âŠ¥) { apply snâ‰ 0 (size lb); symmetry; apply h2; }; apply âŠ¥â‚‘ _ t; }
  }
  { assume ea la h;
    induction
    { simplify; assume i; apply âŠ¥â‚‘ _ (snâ‰ 0 (size la) i);}
    { assume eb lb i; simplify; assume j; have t:Ï€ (size la = size lb) { apply s_inj j; }; apply PH la lb ea eb t (h lb t); }
  }
end;

opaque symbol zip_cat [a b] (la sa:ğ•ƒ a) (lb sb:ğ•ƒ b) : Ï€ (size la = size lb) â†’ Ï€ (zip (la â‹… sa) (lb â‹… sb) = (zip la lb) â‹… (zip sa sb)) â‰”
begin
  assume a b la sa lb sb h;
  apply @seq_ind2 a b (Î» l1:ğ•ƒ a, Î» l2:ğ•ƒ b, (zip (l1 â‹… sa) (l2 â‹… sb) = (zip l1 l2) â‹… (zip sa sb))) _ _ la lb h {
    reflexivity;
  } {
    assume l1 l2 e1 e2 h1 h2; simplify; apply feq (Î» l:ğ•ƒ (a âŠ— b), (e1 ~ e2) â¸¬ l) h2; 
  };
end;

opaque symbol nth_zip [a b] (x:Ï„ a) (y:Ï„ b) (la:ğ•ƒ a) (lb:ğ•ƒ b) i: Ï€ (size la = size lb) â†’ Ï€ (nth (x ~ y) (zip la lb) i = ((nth x la i) ~ (nth y lb i))) â‰”
begin
  assume a b x y;
  induction
  { simplify; assume lb i h; have t: Ï€ (lb = â–¡) { apply size0nil lb; symmetry; apply h; }; rewrite t; reflexivity; }
  { assume ea la h;
    induction
    { simplify; assume i j; apply âŠ¥â‚‘ _ (snâ‰ 0 (size la) j); }
    { assume eb lb k;
      induction
      { simplify; assume m; reflexivity; }
      { simplify; assume i m n; apply h lb i _; apply s_inj n; }
    }
  }
end;

opaque symbol rev_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) : Ï€ (size la = size lb) â†’ Ï€ (rev (zip la lb) = zip (rev la) (rev lb)) â‰”
begin
  assume a b la lb h;
  apply seq_ind2 (Î» l1:ğ•ƒ a, Î» l2:ğ•ƒ b, rev (zip l1 l2) = zip (rev l1) (rev l2)) _ _ la lb h {
    reflexivity;
  } {
    assume l1 l2 e1 e2 i j; simplify; rewrite zip_cat (rev l1) (e1 â¸¬ â–¡) (rev l2) (e2 â¸¬ â–¡) i; simplify; rewrite left j; reflexivity;
  };
end;

// Drop
symbol drop [a] : â„• â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule drop 0 $l â†ª $l
with drop $n â–¡ â†ª â–¡
with drop (s $n) ($x â¸¬ $l) â†ª drop $n $l;

compute drop 3 (7 â¸¬ 2 â¸¬ 3 â¸¬ 1 â¸¬ 41 â¸¬ â–¡);
compute drop 10 (7 â¸¬ 2 â¸¬ 3 â¸¬ 1 â¸¬ 41 â¸¬ â–¡);

opaque symbol drop0 [a] (l:ğ•ƒ a) : Ï€ (drop 0 l = l) â‰”
begin
  reflexivity;
end;

opaque symbol drop_oversize [a] n (l:ğ•ƒ a) : Ï€ (istrue (size l â‰¤ n)) â†’ Ï€ (drop n l = â–¡) â‰”
begin
  assume a;
  induction
  { assume l h; 
    have t:Ï€ (size l = 0) { apply â‰¤0 (size l) h;};
    simplify; apply size0nil l t;
  }
  {
    assume n h;
    induction
    { reflexivity; }
    { assume e l i; simplify; refine h l; }
  }
end;

opaque symbol drop_size [a] (l:ğ•ƒ a) : Ï€ (drop (size l) l = â–¡) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume e l h; simplify; apply h; }
end;

rule drop (size l) l â†ª â–¡;

opaque symbol drop_cons [a] (e:Ï„ a) (l:ğ•ƒ a) : Î  n0, Ï€ (drop (s n0) (e â¸¬ l) = drop n0 l) â‰”
begin
  assume a e l n0; reflexivity;
end;

opaque symbol size_drop [a] (l:ğ•ƒ a) : Î  n0, Ï€ (size (drop n0 l) = size l - n0) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume e l h; simplify; 
    induction
    { reflexivity; }
    { assume n0 i; simplify; apply h n0; } 
  }
end;

opaque symbol size_cons [a] (e:Ï„ a) n (l:ğ•ƒ a): Ï€ (size l = n â‡” size (e â¸¬ l) = s n) â‰”
begin
  assume a e n l;
  apply âˆ§áµ¢ {
    generalize n; induction
    { assume l h; simplify; rewrite h; reflexivity; }
    { assume n h l i; simplify; apply feq s i;}
  } {
    generalize n; induction
    { assume l; simplify; assume i; apply s_inj i;}
    { assume n; simplify; assume h l i; apply s_inj i; }
  };
end;

opaque symbol drop_size_cat [a] n0 (l1:ğ•ƒ a) (l2:ğ•ƒ a) : Ï€ (size l1 = n0) â†’ Ï€ (drop n0 (l1 â‹… l2) = l2) â‰”
begin
  assume a;
  induction
  { assume l1 l2 h; simplify; have t:Ï€ (l1 = â–¡) {apply size0nil l1 h;}; rewrite t; reflexivity; }
  { assume n0 h; 
    induction
    { assume l2; simplify; assume i; apply âŠ¥â‚‘; apply snâ‰ 0 n0; symmetry; apply i; }
    { assume e l1 i l2; simplify; assume j; apply h l1 l2; apply s_inj j; }
  }
end;

opaque symbol drop_drop [a] (l:ğ•ƒ a) n1 n2 : Ï€ (drop n1 (drop n2 l) = drop (n1 + n2) l) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume e l h n1;
    induction
    { reflexivity; }
    { assume n2 i; simplify; apply h n1 n2; }
  }
end;

// Take
symbol take [a] : â„• â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule take 0 $l â†ª â–¡
with take $n â–¡ â†ª â–¡
with take (s $n) ($x â¸¬ $l) â†ª $x â¸¬ (take $n $l);

compute take 3 (7 â¸¬ 2 â¸¬ 3 â¸¬ 1 â¸¬ 41 â¸¬ â–¡);
compute take 10 (7 â¸¬ 2 â¸¬ 3 â¸¬ 1 â¸¬ 41 â¸¬ â–¡);

opaque symbol take0 [a] (l: ğ•ƒ a) : Ï€ (take 0 l = â–¡) â‰”
begin
  reflexivity;
end;

opaque symbol take_cons [a] n (x:Ï„ a) (l:ğ•ƒ a) : Ï€ (take (s n) (x â¸¬ l) = (x â¸¬ take n l)) â‰”
begin
  assume a l; reflexivity;
end;

opaque symbol take_size [a] (l: ğ•ƒ a) : Ï€ (take (size l) l = l) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume e l h; simplify; rewrite h; reflexivity; }
end;

opaque symbol take_oversize [a] n (l:ğ•ƒ a) : Ï€ (istrue (size l â‰¤ n)) â†’ Ï€ (take n l = l) â‰”
begin
  assume a;
  induction
  { assume l h; simplify; symmetry; apply size0nil l; apply â‰¤0 (size l) h; }
  { assume n h; 
    induction
    { reflexivity; }
    { assume e l i; simplify; assume j; rewrite h l j; reflexivity; }
  }
end;

opaque symbol cat_take_drop [a] n (l:ğ•ƒ a) : Ï€ (take n l â‹… drop n l = l) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume n h;
    induction
    { reflexivity; }
    { assume e l i; simplify; rewrite h l; reflexivity; }
  }
end;

opaque symbol size_takel [a] n (l:ğ•ƒ a) : Ï€ (istrue (n â‰¤ size l)) â†’ Ï€ (size (take n l) = n) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume n h;
    induction
    { simplify; assume i; apply âŠ¥â‚‘ _ i; }
    { assume e l i; simplify; assume j; apply feq s; apply h l j; }
  }
end;

//RÃ©cupÃ©rer l'hypothÃ¨se
opaque symbol size_take [a] n (l:ğ•ƒ a) : Ï€ (size (take n l) = if (n < size l) n (size l)) â‰”
begin
  assume a n l;
  refine ind_B (Î» b:ğ”¹, (size (take n l) = (if b n (size l)))) (n < size l) _ _ {
    assume h; rewrite h; simplify;
  } {
    //assume h; rewrite h; simplify;
  };
abort;

opaque symbol size_take_min [a] (n:â„•) (l:ğ•ƒ a) : Ï€ (size (take n l) = min n (size l)) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume n h;
    induction
    { reflexivity; }
    { assume e l i; simplify; apply feq s (h l); }
  }
end;

opaque symbol take_size_cat [a] n (l1 l2:ğ•ƒ a) : Ï€ (size l1 = n) â†’ Ï€ (take n (l1 â‹… l2) = l1) â‰”
begin
  assume a;
  induction
  { assume l1 l2 h; simplify; symmetry; apply size0nil l1 h; }
  { assume n h; 
    induction
    { assume l2; simplify; assume i; apply âŠ¥â‚‘; apply snâ‰ 0 n _; symmetry; apply i; }
    { assume e1 l1 i l2 j; simplify; apply feq (Î» l:ğ•ƒ a, (e1 â¸¬ l)); apply h l1 l2; 
      apply â‡”â‚‘â‚‚ (size l1 = n) (size (e1 â¸¬ l1) = s n) (size_cons e1 n l1) j; 
    }
  }
end;

opaque symbol takel_cat [a] (l1 l2:ğ•ƒ a) : Î  n, Ï€ (istrue (n â‰¤ size l1)) â†’ Ï€ (take n (l1 â‹… l2) = take n l1) â‰”
begin
  assume a;
  induction
  { assume l2 n h; have t:Ï€ (n = 0) { apply â‰¤0 n h; }; rewrite t; reflexivity; }
  { assume e1 l1 h l2;
    induction
    { reflexivity; }
    { assume n i; simplify; assume j; apply feq (Î» l:ğ•ƒ a, e1 â¸¬ l); apply h l2 n j; }
  }
end;

opaque symbol take_drop [a] m n (l:ğ•ƒ a): Ï€ (take m (drop n l) = drop n (take (m + n) l)) â‰”
begin
  assume a;
  induction
  { induction
    { reflexivity; }
    { assume m h;
      induction
      { reflexivity; }
      { assume e l i; simplify; rewrite left .[m in take m l] add0n m; rewrite left h l; reflexivity; }
    }
  }
  { assume n h;
    induction
    { reflexivity; }
    { assume m i; 
      induction
      { reflexivity; }
      { assume e l j; simplify; apply i l; }
    }
  }
end;

opaque symbol takeD [a] m n (l:ğ•ƒ a) : Ï€ (take (m + n) l = take m l â‹… take n (drop m l)) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume m h;
    induction
    { reflexivity; }
    { assume n i;
      induction
      { reflexivity; }
      { assume e l j; simplify; apply feq (Î» l:ğ•ƒ a, e â¸¬ l); rewrite left addnS; apply h (s n) l; }
    }
  }
end;

opaque symbol takeC [a] (l:ğ•ƒ a) i j: Ï€ (take i (take j l) = take j (take i l)) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume e l h;
    induction
    { reflexivity; }
    { assume i h2;
      induction
      { reflexivity; }
      { assume j h3; simplify; rewrite h i j; reflexivity; }
    }
  }
end;

// Rot
symbol rot [a] : â„• â†’ ğ•ƒ a â†’ ğ•ƒ a â‰” Î» n, Î» l, ((drop n l) â‹… (take n l));

compute rot 2 (7 â¸¬ 2 â¸¬ 3 â¸¬ 1 â¸¬ 41 â¸¬ â–¡);

opaque symbol Ï€_rot [a] n (l:ğ•ƒ a) : Ï€ (drop n l â‹… take n l = rot n l) â‰”
begin
  reflexivity;
end;

opaque symbol rot0 [a] (l:ğ•ƒ a) : Ï€ (rot 0 l = l) â‰”
begin
  reflexivity;
end;

opaque symbol size_rot [a] (l:ğ•ƒ a) : Î  n0, Ï€ (size (rot n0 l) = size l) â‰”
begin
  assume a l n0; simplify; rewrite addnC; rewrite left @size_cat a (take n0 l) (drop n0 l);
  rewrite cat_take_drop n0 l; reflexivity; 
end;

opaque symbol rot_oversize [a] n (l:ğ•ƒ a) : Ï€ (istrue (size l â‰¤ n)) â†’ Ï€ (rot n l = l) â‰”
begin
  assume a n l h; simplify; rewrite drop_oversize n l h; rewrite take_oversize n l h; reflexivity;
end;

opaque symbol rot_size [a] (l:ğ•ƒ a) : Ï€ (rot (size l) l = l) â‰”
begin
  assume a l; simplify; rewrite drop_size l; rewrite take_size l; reflexivity;
end;

opaque symbol rot_size_cat [a] (l1 l2:ğ•ƒ a) : Ï€ (rot (size l1) (l1 â‹… l2) = l2 â‹… l1) â‰”
begin
  assume a l1 l2; simplify; 
  rewrite drop_size_cat (size l1) l1 l2 (eq_refl (size l1));
  rewrite take_size_cat (size l1) l1 l2 (eq_refl (size l1));
  reflexivity;
end;

opaque symbol take_take [a] n m : Ï€ (istrue (n â‰¤ m)) â†’ Ï€ (`âˆ€ l:ğ•ƒ a, take n (take m l) = take n l) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume n; simplify; assume h;
    induction
    { simplify; assume i; apply âŠ¥â‚‘ _ i; }
    { assume m i; simplify; assume j;
      induction
      { reflexivity; }
      { assume e l k; simplify; apply feq (Î» l:ğ•ƒ a, e â¸¬ l) (h m j l); }
    }
  }
end;

// Rotr
symbol rotr [a] : â„• â†’ ğ•ƒ a â†’ ğ•ƒ a â‰” Î» n, Î» l, rot (size l - n) l;

compute rotr 2 (7 â¸¬ 2 â¸¬ 3 â¸¬ 1 â¸¬ 41 â¸¬ â–¡);

opaque symbol Ï€_rotr [a] n (l:ğ•ƒ a) : Ï€ (drop (size l - n) l â‹… take (size l - n) l = rotr n l) â‰”
begin
  reflexivity;
end;

opaque symbol rotr0 [a] (l:ğ•ƒ a) : Ï€ (rotr 0 l = l) â‰”
begin
  assume a l; simplify; rewrite drop_size l; rewrite take_size l; reflexivity;
end;

opaque symbol rotK [a] n (l:ğ•ƒ a) : Ï€ (rot n (rotr n l) = l) â‰”
begin
abort;

opaque symbol rot_inj [a] : Î  (n0:â„•), Î  (l1:ğ•ƒ a), Î  (l2:ğ•ƒ a), Ï€ (rot n0 l1 = rot n0 l2) â†’ Ï€ (l1 = l2) â‰”
begin
  assume a;
  induction
  { assume l1 l2 h; rewrite left rot0 l1; rewrite left rot0 l2; apply h; }
  { assume n0 h l1 l2 i; apply h l1 l2; }
abort;

// Inl
symbol inl [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ Ï„ a â†’ ğ•ƒ a â†’ ğ”¹;

rule inl $beq $x â–¡ â†ª false
with inl $beq $x ($y â¸¬ $l) â†ª ($beq $x $y) or (inl $beq $x $l);

compute inl (â‰Œ) 2 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡);
compute inl (â‰Œ) 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡);

opaque symbol in_cons [a] (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) x y (l:ğ•ƒ a) : Ï€ ((inl beq x (y â¸¬ l)) = ((beq x y) or (inl beq x l))) â‰”
begin
  assume a beq x y;
  induction
  { reflexivity; }
  { assume e l h; simplify; reflexivity; }
end;

opaque symbol in_nil [a] (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) x : Ï€ (inl beq x â–¡ = false) â‰”
begin
  assume a beq x; reflexivity;
end;

opaque symbol mem_seq1 [a] (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) x y : Ï€ (inl beq x (y â¸¬ â–¡) = (beq x y)) â‰”
begin
  assume a beq x y; reflexivity;
end;

opaque symbol mem_cat [a] (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) x (l1:ğ•ƒ a) (l2:ğ•ƒ a) : Ï€ ((inl beq x (l1 â‹… l2)) = ((inl beq x l1) or (inl beq x l2))) â‰”
begin
  assume a beq x;
  induction
  { reflexivity; }
  { assume e1 l1 h; simplify; assume l2; rewrite h l2; rewrite orA; reflexivity; }
end;

opaque symbol mem_head [a] (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) x (l:ğ•ƒ a) : Ï€ (beq x x = true) â†’ Ï€ (istrue (inl beq x (x â¸¬ l))) â‰”
begin
  assume a beq x l hrefl; simplify; rewrite hrefl; apply top;
end;

//Lemma mem_last x s : last x s \in x :: s.

opaque symbol mem_take [a] (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) n (l:ğ•ƒ a) x : Ï€ (istrue (inl beq x (take n l))) â†’ Ï€ (istrue (inl beq x l)) â‰”
begin
  assume a beq n l x h;
  rewrite left cat_take_drop n l;
  rewrite mem_cat beq x (take n l) (drop n l);
  refine or_i1 (inl beq x (take n l)) (inl beq x (drop n l)) h;
end;

opaque symbol mem_drop [a] (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) n (l:ğ•ƒ a) x : Ï€ (istrue (inl beq x (drop n l))) â†’ Ï€ (istrue (inl beq x l)) â‰”
begin
  assume a beq n l x h;
  rewrite left cat_take_drop n l;
  rewrite mem_cat beq x (take n l) (drop n l);
  refine or_i2 (inl beq x (take n l)) (inl beq x (drop n l)) h;
end;

//index
symbol index [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ Ï„ a â†’ ğ•ƒ a â†’ â„•;
symbol index_c [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ Ï„ a â†’ ğ•ƒ a â†’ â„• â†’ â„•;

rule index $beq $x â–¡ â†ª 0
with index $beq $x ($y â¸¬ $l) â†ª if ($beq $x $y) 0 (s (index $beq $x $l));

compute index (â‰Œ) 2 (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ â–¡);
compute index (â‰Œ) 26 (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ â–¡);

opaque symbol index_size [a] (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) (x:Ï„ a) (l:ğ•ƒ a) : Ï€ (istrue (index beq x l â‰¤ size l)) â‰”
begin
  assume a beq x;
  induction
  { simplify; apply top; }
  { assume e l h; simplify;
    refine ind_ğ”¹ (Î» b:ğ”¹, istrue (if b 0 (s (index beq x l)) â‰¤ s (size l))) _ _ (beq x e) {
      simplify; apply top;
    } {
      simplify; apply h;
    };
  }
end;

opaque symbol index_head [a] (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) (x:Ï„ a) (l:ğ•ƒ a) : Ï€ (beq x x = true) â†’ Ï€ (index beq x (x â¸¬ l) = 0) â‰”
begin
  assume a beq x l hrefl; simplify; rewrite hrefl; reflexivity;
end;

// Has
symbol has [a] : (Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ”¹;

rule has $p â–¡ â†ª false
with has $p ($x â¸¬ $l) â†ª if ($p $x) true (has $p $l);

symbol prt: â„• â†’ ğ”¹ â‰” Î» x, (x + 1 â‰Œ 3);

compute has prt (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ â–¡);
compute has prt (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡);

// All
symbol all [a] : (Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ”¹;

rule all $p â–¡ â†ª true // Attention Ã  ce cas de la dÃ©finition
with all $p ($x â¸¬ $l) â†ª if ($p $x) (all $p $l) false;

compute all prt (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ â–¡);
compute all prt (2 â¸¬ 2 â¸¬ 2 â¸¬ 2 â¸¬ â–¡);

// Find
symbol find [a] : (Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ â„•;

rule find $p â–¡ â†ª 0
with find $p ($x â¸¬ $l) â†ª if ($p $x) 0 (s (find $p $l));

compute find prt (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ â–¡);
compute find prt (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡);

opaque symbol find_size [a] (pr:Ï„ a â†’ ğ”¹) (l:ğ•ƒ a) : Ï€ (istrue (find pr l â‰¤ size l)) â‰”
begin
  assume a pr;
  induction
  { simplify; apply top; }
  { assume e l; simplify; assume h;
    refine ind_ğ”¹ (Î» x:ğ”¹, istrue (if x 0 (s (find pr l)) â‰¤ s (size l))) _ _ (pr e) {
      simplify; apply top;
    } {
      simplify; apply h;
    };
  }
end;

// Count
symbol count [a] : (Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ â„•;

rule count $p â–¡ â†ª 0
with count $p ($x â¸¬ $l) â†ª if ($p $x) (s (count $p $l)) (count $p $l);

compute count prt (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡);
compute count prt (2 â¸¬ 2 â¸¬ 2 â¸¬ 2 â¸¬ â–¡);

opaque symbol count_size [a] (pr:Ï„ a â†’ ğ”¹) (l:ğ•ƒ a) : Ï€ (istrue (count pr l â‰¤ size l)) â‰”
begin
  assume a pr;
  induction
  { simplify; apply top; }
  { assume e l h; simplify; 
    refine ind_ğ”¹ (Î» x:ğ”¹, istrue (if x (s (count pr l)) (count pr l) â‰¤ s (size l))) _ _ (pr e) {
      simplify; apply h;
    } {
      simplify; refine leq_trans (count pr l) (size l) (s (size l)) h (leqnSn (size l)); 
    };
  }
end;

// Count_mem
symbol count_mem [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ Ï„ a â†’ ğ•ƒ a â†’ â„•;

rule count_mem $beq $e $l â†ª count ($beq $e) $l;

compute count_mem (â‰Œ) 2 (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡);
compute count_mem (â‰Œ) 2 (2 â¸¬ 2 â¸¬ 2 â¸¬ 2 â¸¬ â–¡); 

// Constant
symbol is_constant [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ”¹;

rule is_constant $beq â–¡ â†ª true
with is_constant $beq ($x â¸¬ $l) â†ª if (all ($beq $x) $l) true false;

compute is_constant (â‰Œ) (2 â¸¬ 2 â¸¬ 2 â¸¬ 2 â¸¬ â–¡);
compute is_constant (â‰Œ) â–¡;
compute is_constant (â‰Œ) (2 â¸¬ 2 â¸¬ 2 â¸¬ 1 â¸¬ â–¡);

// Uniq
symbol uniq [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ”¹;

rule uniq $beq â–¡ â†ª true
with uniq $beq ($x â¸¬ $l) â†ª if (not (inl $beq $x $l)) (uniq $beq $l) false;

compute uniq (â‰Œ) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡);
compute uniq (â‰Œ) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡);

// Subseq
symbol subseq [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ”¹;

rule subseq $beq â–¡ â–¡ â†ª true
with subseq $beq â–¡ ($x â¸¬ $l) â†ª false
with subseq $beq ($x â¸¬ $l) â–¡ â†ª false
with subseq $beq ($x â¸¬ $l1) ($y â¸¬ $l2) â†ª if ($beq $x $y) (subseq $beq $l1 $l2) false;

compute subseq (â‰Œ) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡);
compute subseq (â‰Œ) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡);

// Prefix
symbol is_prefix [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ”¹;

rule is_prefix $beq â–¡ _ â†ª true
with is_prefix $beq ($x â¸¬ $l1) â–¡ â†ª false
with is_prefix $beq ($x â¸¬ $l1) ($y â¸¬ $l2) â†ª if ($beq $x $y) (is_prefix $beq $l1 $l2) false;

compute is_prefix (â‰Œ) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡);

// Suffix
symbol is_suffix [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ”¹;

rule is_suffix $beq $l1 $l2 â†ª is_prefix $beq (rev $l1) (rev $l2);

compute is_suffix (â‰Œ) (4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡);

// Infix
symbol is_infix [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ”¹;

rule is_infix $beq â–¡ _ â†ª true
with is_infix $beq ($x â¸¬ $l1) â–¡ â†ª false
with is_infix $beq ($x â¸¬ $l1) ($y â¸¬ $l2) â†ª if ($beq $x $y) (is_prefix $beq $l1 $l2) (is_infix $beq ($x â¸¬ $l1) $l2);

compute is_infix (â‰Œ) (51 â¸¬ 3 â¸¬ â–¡) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡);

// Infix_index
symbol infix_index [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ â„•;

rule infix_index $beq â–¡ _ â†ª 0
with infix_index $beq ($x â¸¬ $l1) â–¡ â†ª 0
with infix_index $beq ($x â¸¬ $l1) ($y â¸¬ $l2) â†ª if ($beq $x $y) (if (is_prefix $beq $l1 $l2) 0 (s (size $l2))) (s (infix_index $beq ($x â¸¬ $l1) $l2));
//(s (size $l2)) because $x :: $l2 

compute infix_index (â‰Œ) (51 â¸¬ 3 â¸¬ â–¡) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡);
compute infix_index (â‰Œ) (51 â¸¬ 4 â¸¬ â–¡) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡);

// Perm_eq
symbol perm_eq [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ”¹;

rule perm_eq $beq $l1 $l2 â†ª all (Î» x, (count_mem $beq x $l1 â‰Œ count_mem $beq x $l2)) ($l1 â‹… $l2);

compute perm_eq (â‰Œ) (59 â¸¬ 58 â¸¬ 4 â¸¬ 2 â¸¬ â–¡) (58 â¸¬ 4 â¸¬ 2 â¸¬ 59 â¸¬ â–¡);
compute perm_eq (â‰Œ) (59 â¸¬ 58 â¸¬ 4 â¸¬ 2 â¸¬ â–¡) (58 â¸¬ 4 â¸¬ 2 â¸¬ 69 â¸¬ â–¡);

//Filter
symbol filter [a] : (Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule filter $p â–¡ â†ª â–¡
with filter $p ($x â¸¬ $l) â†ª if ($p $x) ($x â¸¬ (filter $p $l)) (filter $p $l);

compute filter prt (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ 2 â¸¬ 68 â¸¬ â–¡);

symbol rmfilter [a] : (Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule rmfilter $p â–¡ â†ª â–¡
with rmfilter $p ($x â¸¬ $l) â†ª if ($p $x) (filter $p $l) ($x â¸¬ (filter $p $l));

opaque symbol size_filter [a] (pr:Ï„ a â†’ ğ”¹) (l:ğ•ƒ a) : Ï€ (size (filter pr l) = count pr l) â‰”
begin
  assume a pr;
  induction
  { reflexivity; }
  { assume e l h; simplify;
    refine ind_ğ”¹ (Î» x:ğ”¹, size (if x (e â¸¬ filter pr l) (filter pr l)) = (if x (s (count pr l)) (count pr l))) _ _ (pr e) {
      simplify; apply feq s h;
    } {
      simplify; apply h;
    };
  }
end;

opaque symbol filter_cat [a] (pr:Ï„ a â†’ ğ”¹) (l1 l2:ğ•ƒ a) : Ï€ (filter pr (l1 â‹… l2) = (filter pr l1) â‹… (filter pr l2)) â‰”
begin
  assume a pr;
  induction
  { reflexivity; }
  { assume e1 l1 h l2; simplify;
    refine ind_ğ”¹ (Î» x:ğ”¹, (if x (e1 â¸¬ filter pr (l1 â‹… l2)) (filter pr (l1 â‹… l2))) = (if x (e1 â¸¬ filter pr l1) (filter pr l1) â‹… filter pr l2)) _ _ (pr e1) {
      simplify; rewrite h l2; reflexivity;
    } {
      simplify; rewrite h l2; reflexivity;
    }
  }
end;

opaque symbol filter_rev [a] (pr:Ï„ a â†’ ğ”¹) (l:ğ•ƒ a) : Ï€ (filter pr (rev l) = rev (filter pr l)) â‰”
begin
  assume a pr;
  induction
  { reflexivity; }
  { assume e l h; simplify; rewrite filter_cat pr (rev l) (e â¸¬ â–¡); simplify;
    refine ind_ğ”¹ (Î» b:ğ”¹, (filter pr (rev l) â‹… (if b (e â¸¬ â–¡) â–¡) = rev (if b (e â¸¬ filter pr l) (filter pr l)))) _ _ (pr e) {
      simplify; rewrite h; reflexivity;
    } {
      simplify; rewrite h; reflexivity;
    };
  }
end;

opaque symbol count_cat [a] (pr:Ï„ a â†’ ğ”¹) (l1 l2:ğ•ƒ a) : Ï€ (count pr (l1 â‹… l2) = count pr l1 + count pr l2) â‰”
begin
  assume a pr l1 l2; rewrite left size_filter pr l1; rewrite left size_filter pr l2; rewrite left size_filter pr (l1 â‹… l2);
  rewrite filter_cat pr l1 l2; rewrite left size_cat (filter pr l1) (filter pr l2); reflexivity;
end;

//Some lemmas on lists's equality
opaque symbol eq_find [a] (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) (pr:Ï„ a â†’ ğ”¹) (l1:ğ•ƒ a) (l2:ğ•ƒ a): Ï€ (istrue (# beq l1 l2)) â†’ Ï€ (istrue ((find pr l1) â‰Œ (find pr l2))) â‰”
begin
  assume a beq pr;
  induction
  { simplify; assume l2 h; apply âŠ¥â‚‘ _ h; }
  { assume e1 l1 h;
    induction
    { simplify; assume i; apply âŠ¥â‚‘ _ i; }
    { assume e2 l2 i; simplify; assume j; 
      type ind_B;
      apply ind_B (Î» b:ğ”¹, istrue (if b 0 (s (find pr l1)) â‰Œ if (pr e2) 0 (s (find pr l2)))) (pr e1) _ _ {
        assume k; rewrite k; simplify;
        apply ind_B (Î» b:ğ”¹, istrue (0 â‰Œ if b 0 (s (find pr l2)))) (pr e2) _ _ {
          assume m; rewrite m; simplify; apply top;
        } {
          assume m; rewrite m; simplify;

        }
      } {

      };
      /*apply ind_ğ”¹ (Î» b:ğ”¹, istrue (if b 0 (s (find pr l1)) â‰Œ if (pr e2) 0 (s (find pr l2)))) _ _ (pr e1) {
        simplify; 
        apply ind_ğ”¹ (Î» b:ğ”¹, istrue (0 â‰Œ if b 0 (s (find pr l2)))) _ _ (pr e2) {
          simplify; apply top;
        } {
          simplify; //rewrite beq e1 e2 = false
        };
      } {
        simplify;
        apply ind_ğ”¹ (Î» b:ğ”¹, istrue (s (find pr l1) â‰Œ if b 0 (s (find pr l2)))) _ _ (pr e2) {
          simplify;
        } {
          simplify; apply h l2; apply and_el2 (beq e1 e2) (# beq l1 l2) j;
        }
      };*/
    }
  }
abort;

//Undup
symbol undup [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule undup $beq â–¡ â†ª â–¡
with undup $beq ($x â¸¬ $l) â†ª if (inl $beq $x (undup $beq $l)) (undup $beq $l) ($x â¸¬ (undup $beq $l));

compute undup (â‰Œ) (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ 2 â¸¬ 3 â¸¬ â–¡);

opaque symbol size_undup [a] (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) (l:ğ•ƒ a) : Ï€ (istrue (size (undup beq l) â‰¤ size l)) â‰”
begin
  assume a beq;
  induction
  { simplify; apply top; }
  { assume e l h; simplify; 
    refine ind_ğ”¹ (Î» x:ğ”¹, istrue (size (if x (undup beq l) (e â¸¬ (undup beq l))) â‰¤ s (size l))) _ _ (inl beq e (undup beq l)) {
      simplify;
      refine leq_trans (size (undup beq l)) (size l) (s (size l)) h (leqnSn (size l));
    } {
      simplify; apply h;
    }; 
  }
end;

opaque symbol undup_uniq [a] (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) (l:ğ•ƒ a) : Ï€ (istrue (uniq beq (undup beq l))) â‰”
begin
  assume a beq;
  induction
  { simplify; apply top; }
  { assume e l h; simplify;
    refine ind_B (Î» b:ğ”¹, (istrue(uniq beq (if b (undup beq l) (e â¸¬ (undup beq l)))))) (inl beq e (undup beq l)) _ _ {
      assume i; rewrite i; simplify; apply h;
    } {
      assume i; rewrite i; simplify; rewrite i; simplify; apply h; 
    }; 
  }
end;

opaque symbol filter_undup [a] (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) (pr:Ï„ a â†’ ğ”¹) (l:ğ•ƒ a) : Ï€ (filter pr (undup beq l) = undup beq (filter pr l)) â‰”
begin
  assume a beq pr;
abort;

opaque symbol count_undup [a] (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) (pr:Ï„ a â†’ ğ”¹) (l:ğ•ƒ a) : Ï€ (istrue (count pr (undup beq l) â‰¤ count pr l)) â‰”
begin
  assume a beq pr l;
  rewrite left size_filter pr l;
  rewrite left size_filter pr (undup beq l);
abort;

//Map
symbol map [a b] : (Ï„ a â†’ Ï„ b) â†’ ğ•ƒ a â†’ ğ•ƒ b;

rule map $f â–¡ â†ª â–¡
with map $f ($x â¸¬ $l) â†ª ($f $x) â¸¬ (map $f $l);

symbol ft : Ï„ nat â†’ ğ”¹;
rule ft $x â†ª boolification (istrue (3 â‰¤ $x));

compute map (ft) (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ â–¡);

opaque symbol map_cons [a b] (f:Ï„ a â†’ Ï„ b) (l:ğ•ƒ a) : Î  x:Ï„ a, Ï€ ((map f (x â¸¬ l)) = ((f x) â¸¬ (map f l))) â‰”
begin
  assume a b f l x; reflexivity;
end;

opaque symbol map_cat [a b] (f:Ï„ a â†’ Ï„ b) (l1:ğ•ƒ a) (l2:ğ•ƒ a) : Ï€ (map f (l1 â‹… l2) = map f l1 â‹… map f l2) â‰”
begin
  assume a b f;
  induction
  { reflexivity; }
  { assume e1 l1 h l2; simplify; rewrite h l2; reflexivity; }
end;

opaque symbol size_map [a b] (f:Ï„ a â†’ Ï„ b) (l:ğ•ƒ a) : Ï€ (size (map f l) = size l) â‰”
begin
  assume a b f;
  induction
  { reflexivity; }
  { assume e l h; simplify; apply feq s h; }
end;

opaque symbol behead_map [a b] (f:Ï„ a â†’ Ï„ b) (l:ğ•ƒ a): Ï€ (behead (map f l) = map f (behead l)) â‰”
begin
  assume a b f;
  induction
  { reflexivity; }
  { assume e l h; reflexivity; }
end;

opaque symbol map_rcons [a b] (f:Ï„ a â†’ Ï„ b) (l:ğ•ƒ a) (e:Ï„ a) : Ï€ (map f (rcons l e) = rcons (map f l) (f e)) â‰”
begin
  assume a b f;
  induction
  { reflexivity; }
  { assume x l h e; simplify; rewrite h e; reflexivity; }
end;

opaque symbol last_map [a b] (f:Ï„ a â†’ Ï„ b) (l:ğ•ƒ a) (x:Ï„ a) : Ï€ (last (f x) (map f l) = f (last x l)) â‰”
begin
  assume a b f;
  induction
  { reflexivity; }
  { assume e l h x; simplify; rewrite h e; reflexivity; }
end;

opaque symbol belast_map [a b] (f:Ï„ a â†’ Ï„ b) (l:ğ•ƒ a) (x:Ï„ a) : Ï€ (belast (f x) (map f l) = map f (belast x l)) â‰”
begin
  assume a b f;
  induction
  { reflexivity; }
  { assume e l h x; simplify; rewrite h e; reflexivity; }
end;

opaque symbol map_take [a b] (f:Ï„ a â†’ Ï„ b) n (l:ğ•ƒ a) : Ï€ (map f (take n l) = take n (map f l)) â‰”
begin
  assume a b f;
  induction
  { reflexivity; }
  { assume n h;
    induction
    { reflexivity; }
    { assume e l i; simplify; rewrite h l; reflexivity; } 
  }
end;

opaque symbol map_drop [a b] (f:Ï„ a â†’ Ï„ b) n (l:ğ•ƒ a) : Ï€ (map f (drop n l) = drop n (map f l)) â‰”
begin
  assume a b f;
  induction
  { reflexivity; }
  { assume n h;
    induction
    { reflexivity; }
    { assume e l i; simplify; rewrite h l; reflexivity; } 
  }
end;

opaque symbol map_rot [a b] (f:Ï„ a â†’ Ï„ b) n (l:ğ•ƒ a) : Ï€ (map f (rot n l) = rot n (map f l)) â‰”
begin
  assume a b f n l; simplify; rewrite map_cat f (drop n l) (take n l);
  rewrite map_take f n l; rewrite map_drop f n l; reflexivity; 
end;

opaque symbol map_rotr [a b] (f:Ï„ a â†’ Ï„ b) n (l:ğ•ƒ a) : Ï€ (map f (rotr n l) = rotr n (map f l)) â‰”
begin
  assume a b f n l; simplify; rewrite map_cat f (drop (size l - n) l) (take (size l - n) l);
  rewrite map_drop f (size l - n) l; rewrite map_take f (size l - n) l;
  rewrite size_map f l; reflexivity;
end;

opaque symbol map_rev [a b] (f:Ï„ a â†’ Ï„ b) (l:ğ•ƒ a) : Ï€ (map f (rev l) = rev (map f l)) â‰”
begin
  assume a b f;
  induction
  { reflexivity; }
  { assume e l h; simplify; rewrite map_cat f (rev l) (e â¸¬ â–¡); rewrite h; simplify; reflexivity; }
end;

symbol aay [a] (e:Ï„ a) (l:ğ•ƒ a): Ï€ ((e â¸¬ l) = â–¡) â†’ Ï€ (âŠ¥);
symbol aai [a] (e1 e2:Ï„ a) (l1 l2:ğ•ƒ a): Ï€ ((e1 â¸¬ l1) = (e2 â¸¬ l2) â‡” (e1 = e2) âˆ§ (l1 = l2));

opaque symbol inj_map [a b] (f:Ï„ a â†’ Ï„ b) : Ï€ (`âˆ€ x, `âˆ€ y, f x = f y â‡’ x = y) â†’ Î  l1:ğ•ƒ a, Î  l2:ğ•ƒ a, Ï€ (map f l1 = map f l2) â†’ Ï€ (l1 = l2) â‰”
begin
  assume a b f h;
  induction
  { induction
    { reflexivity; }
    { assume e l i; simplify; assume j; apply âŠ¥â‚‘; 
      have t:Ï€ (âŠ¥) { apply aay (f e) (map f l); symmetry; apply j; }; apply t;
    }
  }
  { assume e1 l1 i;
    induction
    { simplify; assume j; apply âŠ¥â‚‘;
      have t:Ï€ (âŠ¥) { apply aay (f e1) (map f l1) j; }; apply t;
    }
    {
      assume e2 l2 j; simplify; assume k;
      have t:Ï€ (f e1 = f e2 âˆ§ map f l1 = map f l2) {
        apply â‡”â‚‘â‚ ((f e1 â¸¬ map f l1) = (f e2 â¸¬ map f l2)) (f e1 = f e2 âˆ§ map f l1 = map f l2) (aai (f e1) (f e2) (map f l1) (map f l2)) k;
      };
      have t1: Ï€ (f e1 = f e2) { apply âˆ§â‚‘â‚ (f e1 = f e2) (map f l1 = map f l2) t; };
      have t2: Ï€ (map f l1 = map f l2) { apply âˆ§â‚‘â‚‚ (f e1 = f e2) (map f l1 = map f l2) t; };
      apply â‡”â‚‘â‚‚ ((e1 â¸¬ l1) = (e2 â¸¬ l2)) (e1 = e2 âˆ§ l1 = l2) (aai e1 e2 l1 l2);
      apply âˆ§áµ¢ (e1 = e2) (l1 = l2) {
        apply h e1 e2 t1;
      } {
        apply i l2 t2;
      };
    }
  }
end;

// sumn
symbol sumn : ğ•ƒ nat â†’ â„•;

rule sumn â–¡ â†ª 0
with sumn ($x â¸¬ $l) â†ª $x + sumn $l;

compute sumn (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡);

// prodn
symbol prodn : ğ•ƒ nat â†’ â„•;

rule prodn â–¡ â†ª 1
with prodn ($x â¸¬ $l) â†ª $x Ã— (prodn $l);

compute prodn (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡);