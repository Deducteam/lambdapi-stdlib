require open Stdlib.Set Stdlib.Logic Stdlib.Nat Stdlib.Bool;

// Type of polymorphic lists

constant symbol list : Set â†’ Set;

(a:Set) inductive ğ•ƒ:TYPE â‰”
| â–¡ : ğ•ƒ a
| cons : Ï„ a â†’ ğ•ƒ a â†’ ğ•ƒ a;

set infix 4 "â¸¬" â‰” cons; // :: 

rule ğ•ƒ $a â†ª Ï„ (list $a);

// Length of a list

symbol length {a} : ğ•ƒ a â†’ â„•;

rule length â–¡ â†ª 0
with length (_ â¸¬ $l) â†ª suc (length $l);

// Concatenation of two lists

symbol concat {a} : ğ•ƒ a â†’ ğ•ƒ a â†’ ğ•ƒ a;

set infix right 5 "â‹…" â‰” concat; // \cdot

assert a (x y z:ğ•ƒ a) âŠ¢ x â‹… y â‹… z â‰¡ x â‹… (y â‹… z);
assert a x l m âŠ¢ x â¸¬ l â‹… m â‰¡ x â¸¬ (l â‹… m);

rule â–¡ â‹… $m â†ª $m
with ($x â¸¬ $l) â‹… $m â†ª $x â¸¬ ($l â‹… $m);

opaque symbol concat_nil {a} (l:ğ•ƒ a) : Ï€(l â‹… â–¡ = l) â‰”
begin
  assume a;
  refine ind_ğ•ƒ _ _ _ _;
  // case l = â–¡
  reflexivity;
  // case l = x â¸¬ l'
  assume x l' h;
  simpl;
  rewrite h;
  reflexivity;
end;

rule $m â‹… â–¡ â†ª $m;

opaque symbol length_concat {a} (l m : ğ•ƒ a) :
  Ï€(length (l â‹… m) = length l + length m) â‰”
begin
  assume a;
  refine ind_ğ•ƒ _ _ _ _;
  // case l = â–¡
  assume m;
  reflexivity;
  // case l = xâ¸¬l'
  assume x l' h m;
  simpl;
  rewrite h;
  reflexivity;
end;

rule length ($l â‹… $m) â†ª length $l + length $m;

opaque symbol concat_assoc {a} (l m n : ğ•ƒ a) : Ï€((l â‹… m) â‹… n = l â‹… (m â‹… n)) â‰”
begin
  assume a;
  refine ind_ğ•ƒ _ _ _ _;
  // case l = â–¡
  assume m n;
  reflexivity;
  // case l = xâ¸¬l'
  assume x l' h m n;
  simpl;
  rewrite h;
  reflexivity;
end;

rule ($l â‹… $m) â‹… $n â†ª $l â‹… ($m â‹… $n);
