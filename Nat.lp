// Natural numbers

/*
 * Some proofs are not finished and ended by the keyword abort:
 * ltn_neqAle, leq_eqVlt, gtn_max, geq_max, minnE, expn_gt0, ltn_expl
 * The proof of leq_eqVlt uses leq_eqVlt because I almost finished it.
 */

require open Blanqui.Lib.Set Blanqui.Lib.Prop Blanqui.Lib.FOL Blanqui.Lib.Eq;

inductive â„• : TYPE â‰”
| zero : â„•
| s : â„• â†’ â„•;

// set code for â„•

constant symbol nat : Set;

rule Ï„ nat â†ª â„•;

// Enabling the use of decimal notation

builtin "0"  â‰” zero;
builtin "+1" â‰” s;

assert âŠ¢ 42 : â„•;

// is0 predicate

symbol is0 : â„• â†’ Prop;

rule is0 0 â†ª âŠ¤
with is0 (s _) â†ª âŠ¥;

// s _ â‰  0

opaque symbol sâ‰ 0 n : Ï€ (s n â‰  0) â‰”
begin
  assume n h; refine ind_eq h is0 top
end;

// predecessor function

symbol p : â„• â†’ â„•;

rule p 0 â†ª 0
with p (s $x) â†ª $x;

// s is injective

opaque symbol s_inj [x y] : Ï€ (s x = s y) â†’ Ï€ (x = y) â‰”
begin
  assume x y h; apply feq p h
end;

constant symbol prop : Set;
rule Ï„ prop â†ª Prop; 

opaque symbol snâ‰ 0 n : Ï€ (s n = 0) â†’ Ï€ (âŠ¥) â‰”
begin
  assume n h;
  have t: Ï€ (@= prop âŠ¥ âŠ¤) { apply feq is0 h; };
  have u: Ï€ (âŠ¥) { apply ind_eq t (Î» x, x); apply top; };
  apply u;
end;

// Addition

symbol + : â„• â†’ â„• â†’ â„•;

notation + infix left 20;

assert x y z âŠ¢ x + y + z â‰¡ (x + y) + z; // check associativity

rule 0 + $y â†ª $y
with s $x + $y â†ª s ($x + $y);

opaque symbol add0n x : Ï€ (0 + x = x) â‰”
begin
  assume x; reflexivity;
end;

opaque symbol addn0 x : Ï€ (x + 0 = x) â‰”
begin
  induction
  { reflexivity }
  { assume x' h; simplify; rewrite h; reflexivity }
end;

rule $x + 0 â†ª $x;

opaque symbol addSn x y : Ï€ (s x + y = s (x + y)) â‰”
begin
  assume x; reflexivity;
end;

opaque symbol addnS x y : Ï€ (x + s y = s (x + y)) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y; simplify; rewrite h; reflexivity }
end;

rule $x + s $y â†ª s ($x + $y);

opaque symbol add1n n : Ï€ (1 + n = s n) â‰”
begin
  assume n; reflexivity;
end;

opaque symbol addn1 n : Ï€ (n + 1 = s n) â‰”
begin
  assume n; reflexivity;
end;

opaque symbol addSnnS m n : Ï€ (s m + n = m + s n) â‰”
begin
  assume m n; reflexivity;
end;

// Addition is commutative

opaque symbol addnC x y : Ï€ (x + y = y + x) â‰”
begin
  induction
  { reflexivity }
  { simplify; assume x' h y; rewrite h; reflexivity }
end;

// Addition is associative

opaque symbol addnA x y z : Ï€ ((x + y) + z = x + (y + z)) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y z; simplify; rewrite h; reflexivity }
end;

rule ($x + $y) + $z â†ª $x + ($y + $z);

opaque symbol addnCA m n p : Ï€ ((m + n) + p = (m + p) + n) â‰”
begin
  assume m n p; symmetry; rewrite addnA; rewrite .[p + n] addnC; rewrite left addnA; reflexivity;
end;

opaque symbol addnAC m n p : Ï€ (m + (n + p) = n + (m + p)) â‰”
begin
  assume m n p; symmetry; rewrite left addnA; rewrite .[n + m] addnC; rewrite addnA; reflexivity; 
end;

opaque symbol addnCAC m n p : Ï€ (m + n + p = p + n + m) â‰”
begin
  assume m n p; rewrite addnC; rewrite .[m + _] addnC; rewrite addnA; reflexivity; 
end;

opaque symbol addnACl m n p : Ï€ (m + n + p = n + (p + m)) â‰”
begin
  assume m n p; rewrite .[m + _] addnC; rewrite addnA; rewrite .[m + _] addnC; reflexivity;
end;

opaque symbol addnACA m n p q : Ï€ ((m + n) + (p + q) = (m + p) + (n + q)) â‰”
begin
  assume m n p q; simplify; rewrite left .[p + (n + q)] addnA; rewrite .[p + n] addnC; rewrite .[(n + p) + q] addnA; reflexivity; 
end;

//Compatibility with addition
opaque symbol addnI x y z : Ï€ (z + x = z + y) â†’ Ï€ (x = y) â‰”
begin
  assume x y;
  induction
  { simplify; assume h; apply h;}
  { assume z h i; apply h; apply s_inj; apply i;}
end;

opaque symbol addIn x y z : Ï€ (x + z = y + z) â†’ Ï€ (x = y) â‰”
begin
  assume x y;
  induction
  { simplify; assume h; apply h;}
  { assume z h i; apply h; apply s_inj; apply i;}
end;

opaque symbol addn_eq0 m n : Ï€ (m + n = 0 â‡” m = 0 âˆ§ n = 0) â‰”
begin
  assume m n;
  apply  âˆ§áµ¢ {
    generalize m;
    induction
    { assume m; simplify; assume h; apply âˆ§áµ¢ (0 = 0) (m = 0) (eq_refl 0) h; }
    { assume m h n; simplify; assume i; 
      have t:Ï€ (âŠ¥) { apply snâ‰ 0 _ i; };
      apply âŠ¥â‚‘; apply t;
    }
  } {
    generalize m;
    induction
    { assume n h; 
      have t:Ï€ (n = 0) { apply âˆ§â‚‘â‚‚ _ _ h; };
      apply t;
    }
    { assume m h n i; 
      have t:Ï€ (s m = 0) { apply âˆ§â‚‘â‚ _ _ i; };
      have u:Ï€ (n = 0) { apply âˆ§â‚‘â‚‚ _ _ i; };
      rewrite u; apply t;
    }
  }
end;

opaque symbol eqn_add2l p m n : Ï€ ((p + m = p + n) â‡” (m = n)) â‰”
begin
  assume p m n;
  apply âˆ§áµ¢ {
    refine addnI m n p;
  } {
    generalize m; generalize p;
    induction
    { assume m n;simplify; assume h; apply h;}
    { assume z; simplify; assume h m n i; rewrite h m n i; reflexivity; }  
  };
end;

opaque symbol eqn_add2r p m n : Ï€ ((m + p = n + p) â‡” (m = n)) â‰”
begin
  assume p m n; rewrite addnC m p; rewrite addnC n p; apply eqn_add2l p m n;
end;

//Soustraction

symbol - : â„• â†’ â„• â†’ â„•;

notation - infix left 20;

rule 0 - $x â†ª 0
with $x - 0 â†ª $x
with (s $x) - (s $y) â†ª $x - $y;

opaque symbol sub0n n : Ï€ (n - 0 = n) â‰”
begin
  reflexivity;
end;

opaque symbol subn0 n : Ï€ (0 - n = 0) â‰”
begin
  reflexivity;
end;

opaque symbol subnn x : Ï€ (x - x = 0) â‰”
begin
  induction
  { reflexivity }
  { assume x h; simplify; apply h;}
end;

rule $x - $x â†ª 0;

symbol sub x y â‰” x - y;

opaque symbol subSS m n : Ï€ (s m - s n = m - n) â‰”
begin
  reflexivity;
end;

opaque symbol subn1 n : Ï€ (n - 1 = p n) â‰”
begin
  induction
  { reflexivity; }
  { assume n h; reflexivity;  }
end;

opaque symbol subnS x y : Ï€ (x - s y = p (x - y)) â‰”
begin
  induction
  { reflexivity; }
  { assume x h; simplify; 
    induction
    { reflexivity; }
    { assume y i; simplify; rewrite h; reflexivity }
  }
end;

opaque symbol subSnn n : Ï€ (s n - n = 1) â‰”
begin
  induction
  { reflexivity; }
  { assume n h; simplify; apply h; }
end;

opaque symbol predn_sub x y : Ï€ (p (x - y) = p x - y) â‰”
begin
  induction
  { reflexivity; }
  { assume x h; 
    induction
    { reflexivity; }
    { assume y i; simplify; symmetry; rewrite subnS; reflexivity; }
  }
end;

opaque symbol subnAC z x y : Ï€ ((x - y) - z = (x - z) - y) â‰”
begin
  induction
  { reflexivity; }
  { assume z h;
    induction
    { reflexivity; }   
    { assume x i;
      induction
      { reflexivity; }
      { assume y j; simplify; rewrite i; rewrite subnS; symmetry; rewrite subnS; rewrite predn_sub; reflexivity}
    }
  }
end;

opaque symbol addnK x y : Ï€ (x + y - y = x) â‰”
begin
  induction
  { reflexivity; }
  { assume x h; simplify;
    induction
    { reflexivity; }
    { assume y i; simplify; rewrite i; reflexivity; }
  }
end;

opaque symbol subnDA x y z : Ï€ (x - (y + z) = (x - y) - z) â‰”
begin
  induction
  { reflexivity }
  { assume x h; simplify; 
    induction
    { reflexivity }
    { assume y i; simplify;
      induction
      { reflexivity }
      { assume z j; simplify; rewrite subnS; symmetry; rewrite subnS; rewrite h; reflexivity; }
    }
  }
end;

opaque symbol subnDl z x y : Ï€ ((z + x) - (z + y) = x - y) â‰”
begin
  induction
  { reflexivity }
  { assume z h; simplify; 
    induction
    { assume y; simplify; rewrite subnDA; reflexivity; }
    { assume x i;
      induction
      { rewrite addnC; rewrite addn0; rewrite addnK; reflexivity; }
      { assume y j; rewrite addnC; rewrite subnDA; rewrite addnK; reflexivity }
    }
  }
end;

opaque symbol subnDr z x y : Ï€ ((x + z) - (y + z) = x - y) â‰”
begin
  assume z x y; rewrite addnC; rewrite .[y + _] addnC; rewrite subnDl; reflexivity;
end;

opaque symbol subSKn m n : Ï€ (p (s m - n) = m - n) â‰”
begin
  assume m n; rewrite left subnS; simplify; reflexivity;
end;

// Multiplication

symbol Ã— : â„• â†’ â„• â†’ â„•; // \times

notation Ã— infix left 30;

assert x y z âŠ¢ x + y Ã— z â‰¡ x + (y Ã— z); // check priorities

rule 0 Ã— _  â†ª 0
with s $x Ã— $y â†ª $y + $x Ã— $y;

// Multiplication is commutative

opaque symbol mul0n x : Ï€ (x Ã— 0 = 0) â‰”
begin
  induction { reflexivity } { assume x' h; apply h }
end;

rule _ Ã— 0 â†ª 0;

opaque symbol muln0 x : Ï€ (0 Ã— x = 0) â‰”
begin
  assume x; simplify; reflexivity;
end;

opaque symbol mul1n n : Ï€ (1 Ã— n = n) â‰”
begin
  assume n; simplify; reflexivity;
end;

opaque symbol muln1 n : Ï€ (n Ã— 1 = n) â‰”
begin
  induction
  { simplify; reflexivity; }
  { assume n h; simplify; rewrite h; reflexivity; }
end;

opaque symbol mulSn m n : Ï€ (s m Ã— n = n + m Ã— n) â‰”
begin
  induction
  { reflexivity }
  { assume m h n; simplify; reflexivity }
end;

opaque symbol mulSnr m n : Ï€ (s m Ã— n = m Ã— n + n) â‰”
begin
  induction
  { reflexivity }
  { assume m h n; simplify; rewrite .[n + (m Ã— n)] addnC; reflexivity }
end;

opaque symbol mulnS x y : Ï€ (x Ã— s y = x + x Ã— y) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y; simplify; rewrite h; rewrite addnAC; reflexivity }
end;

opaque symbol mulnSr x y : Ï€ (x Ã— s y = x Ã— y + x) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y; simplify; rewrite h; reflexivity }
end;

rule $x Ã— s $y â†ª $x + $x Ã— $y;

opaque symbol mulnC x y : Ï€ (x Ã— y = y Ã— x) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y; simplify; rewrite h; reflexivity }
end;

// Multiplication distributes over addition

opaque symbol mulnDl x y z : Ï€ ((x + y) Ã— z = x Ã— z + y Ã— z) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y z; simplify; rewrite h; reflexivity }
end;

rule ($x + $y) Ã— $z â†ª $x Ã— $z + $y Ã— $z;

opaque symbol mulnDr x y z : Ï€ (z Ã— (x + y) = z Ã— x + z Ã— y) â‰”
begin
  assume x y z; rewrite mulnC; rewrite mulnDl; rewrite mulnC;
  rewrite .[y Ã— _] mulnC; reflexivity
end;

rule $z Ã— ($x + $y) â†ª $z Ã— $x + $z Ã— $y;

opaque symbol mulnBr x y z : Ï€ (x Ã— (y - z) = x Ã— y - x Ã— z) â‰”
begin
  induction
  { reflexivity; }
  { assume x h;
    induction
    { reflexivity; }
    { assume y i;
      induction
      { reflexivity; }
      { assume z j; simplify; rewrite left addnAC; rewrite .[z + (x + _)] addnAC; 
        rewrite subnDl; rewrite left mulSn; rewrite left mulSn; rewrite left mulSn; rewrite left i; reflexivity; }
    }
  }
end;

opaque symbol mulnBl x y z : Ï€ ((x - y) Ã— z = x Ã— z - y Ã— z) â‰”
begin
  assume x y z; rewrite mulnC; rewrite .[x Ã— z] mulnC; rewrite .[y Ã— z] mulnC; rewrite left mulnBr; reflexivity;
end;

// Multiplication is associative

opaque symbol mulnA x y z : Ï€ ((x Ã— y) Ã— z = x Ã— (y Ã— z)) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y z; simplify; rewrite h; reflexivity }
end;

rule ($x Ã— $y) Ã— $z â†ª $x Ã— ($y Ã— $z);

opaque symbol mulnCA x y z: Ï€ (x Ã— (y Ã— z) = y Ã— (x Ã— z)) â‰”
begin
  assume x y z; rewrite left mulnA; rewrite .[x Ã— y] mulnC; rewrite mulnA; reflexivity;
end;

opaque symbol mulnAC x y z: Ï€ ((x Ã— y) Ã— z = (x Ã— z) Ã— y) â‰”
begin
  assume x y z; rewrite mulnA; rewrite .[y Ã— z] mulnC; rewrite left mulnA; reflexivity;
end;

opaque symbol mulnACA x y z t: Ï€ ((x Ã— y) Ã— (z Ã— t) = (x Ã— z) Ã— (y Ã— t)) â‰”
begin
  assume x y z t; simplify; rewrite .[z Ã— (_ Ã— _)] mulnCA; reflexivity;
end;

opaque symbol muln_eq0 m n : Ï€ ((m Ã— n = 0) â‡” (m = 0) âˆ¨ (n = 0)) â‰”
begin
  assume m n; 
  apply âˆ§áµ¢ {
    generalize m;
    induction
    { simplify; assume n h; apply âˆ¨áµ¢â‚ _ _ h; }
    { assume m h n; simplify; assume i; 
      have t: Ï€ (n = 0 âˆ§ (m Ã— n) = 0) { apply âˆ§â‚‘â‚ _ _ (addn_eq0 n (m Ã— n)) i; }; 
      have u: Ï€ (n = 0) { apply âˆ§â‚‘â‚ _ _ t; };
      apply âˆ¨áµ¢â‚‚ _ _ u;
    }
  } {
    assume h;
    refine âˆ¨â‚‘ _ _ _ h _ _ {
      assume i; rewrite i; reflexivity;
    } {
      assume i; rewrite i; reflexivity;
    };  
  };
end;

/************************************
************** Order on â„• ***********
*************************************/

require open Blanqui.Lib.Bool;

symbol â‰¤ : â„• â†’ â„• â†’ ğ”¹;
notation â‰¤ infix left 10;

rule 0 â‰¤ $y â†ª true
with s $x â‰¤ 0 â†ª false
with (s $x â‰¤ s $y) â†ª $x â‰¤ $y;

symbol < : â„• â†’ â„• â†’ ğ”¹;
notation < infix 10;
rule $x < $y â†ª s $x â‰¤ $y;

symbol â‰¥ : â„• â†’ â„• â†’ ğ”¹;
notation â‰¥ infix 10;
rule $x â‰¥ $y â†ª $y â‰¤ $x;

symbol > : â„• â†’ â„• â†’ ğ”¹;
notation > infix 10;
rule $x > $y â†ª s $y â‰¤ $x;

opaque symbol â‰¤0 x : Ï€ (istrue (x â‰¤ 0)) â†’ Ï€ (x = 0) â‰”
begin
  induction
  { assume h; reflexivity;}
  { assume x h; simplify; assume i; apply âŠ¥â‚‘; apply i; }
end;

// â‰¤ is reflexive
opaque symbol â‰¤_refl x : Ï€ (istrue (x â‰¤ x)) â‰”
begin
  induction
  { simplify; apply top;}
  { assume x h; simplify; apply h; }
end;

opaque symbol eq_leq x y : Ï€ (x = y) â†’ Ï€ (istrue (x â‰¤ y)) â‰”
begin 
  assume x y h;
  rewrite h;
  apply â‰¤_refl y;
end;

// â‰¤ is transitive
opaque symbol leq_trans x y z : Ï€ (istrue (x â‰¤ y)) â†’ Ï€ (istrue (y â‰¤ z)) â†’ Ï€ (istrue (x â‰¤ z)) â‰”
begin
  induction
  { assume y z; simplify; assume h i; apply h; }
  { assume x h; 
    induction
    { assume y; simplify; assume i; apply âŠ¥â‚‘ _ i; }
    { assume y i; 
      induction
      { simplify; assume j k; apply k; }
      { assume z; simplify; assume j k l; apply h y z k l; }
    }
  }
end;

// â‰¤ is antisymmetric
opaque symbol eqn_leq x y : Ï€ (istrue (x â‰¤ y) âˆ§ istrue (y â‰¤ x) â‡” (x = y)) â‰”
begin
  assume x y;
  apply âˆ§áµ¢ {
    generalize x;
    induction
    { assume y g; 
      have i: Ï€ (istrue (y â‰¤ 0)) { apply âˆ§â‚‘â‚‚ _ _ g; };
      symmetry; apply â‰¤0 y i;
    }
    {
      assume x h;
      induction
      { assume g; 
        have i: Ï€ (istrue (s x â‰¤ 0)) { apply âˆ§â‚‘â‚ _ _ g; };
        apply â‰¤0 (s x) i;
      }
      { assume y i; simplify; assume j; apply feq s; apply h y j;}
    }
  } {
    assume h;
    have t: Ï€ (istrue (x â‰¤ y)) { apply eq_leq _ _ h;};
    have u: Ï€ (istrue (y â‰¤ x)) { apply eq_leq y x _; symmetry; apply h;};
    apply âˆ§áµ¢ _ _ t u;
  };
end;

opaque symbol leqsnn n: Ï€ (istrue (s n â‰¤ n)) â†’ Ï€ âŠ¥ â‰”
begin
  induction
  { simplify; assume h; apply h; }
  { assume n h; simplify; assume i; apply h; apply i;}
end;

opaque symbol letnS m n : Ï€ (istrue (m < s n)) â†’ Ï€ (istrue (m â‰¤ n)) â‰”
begin
  assume m n; simplify; assume h; apply h;
end;

opaque symbol ltn0 n : Ï€ (istrue (n < 0)) â†’ Ï€ âŠ¥ â‰”
begin
  assume n h; apply h;
end;

// < is antirefelxive
opaque symbol ltnn n : Ï€ (istrue (n < n)) â†’ Ï€ âŠ¥ â‰”
begin
  assume n; simplify; assume h; apply leqsnn n; apply h;
end;

opaque symbol ltnSn n : Ï€ (istrue (n < s n)) â‰”
begin
  assume n; simplify; apply â‰¤_refl n;
end;

opaque symbol leq0n n : Ï€ (istrue (0 â‰¤ n)) â‰”
begin
  induction
  { apply â‰¤_refl 0;}
  { assume n h; simplify; apply h; }
end;

opaque symbol ltn0Sn n : Ï€ (istrue (0 < s n)) â‰”
begin
  assume n; apply leq0n n;
end;

opaque symbol leqnSn n : Ï€ (istrue (n â‰¤ s n)) â‰”
begin
  induction
  { apply leq0n 1; }
  { assume n h; simplify; apply h; }
end;

opaque symbol leq_pred n : Ï€ (istrue (p n â‰¤ n)) â‰”
begin
  induction
  { simplify; apply top;}
  { assume n h; simplify; apply leqnSn n;} 
end;

opaque symbol ltnW m n : Ï€ (istrue (m < n)) â†’ Ï€ (istrue (m â‰¤ n)) â‰”
begin
  induction
  { simplify; assume m h; apply top;}
  { simplify; assume m h;
    induction
    { simplify; assume i; apply i;}
    { simplify; assume n i j; apply h n; apply j;}
  }
end;

// < is transitive

opaque symbol leqW m n : Ï€ (istrue (m â‰¤ n)) â†’ Ï€ (istrue (m â‰¤ s n)) â‰”
begin
  assume m n h; apply ltnW m (s n); simplify; apply h;
end;

opaque symbol ltn_trans x y z : Ï€ (istrue (x < y)) â†’ Ï€ (istrue (y < z)) â†’ Ï€ (istrue (x < z)) â‰”
begin
  assume x y z; simplify; assume h i;
  have v:Ï€ (istrue (s x â‰¤ s y)) { apply leqW (s x) y h; };
  apply leq_trans (s x) (s y) z v i;
end;

// < is asymmetric
opaque symbol <_asym x y : Ï€ (istrue (x < y)) â†’ Ï€ (Â¬ (istrue (y < x))) â‰”
begin
  assume x y; simplify; assume h i;
  have t:Ï€ (istrue (y â‰¤ s y)) { apply leqnSn y; };
  have u:Ï€ (istrue (s x â‰¤ s y)) { apply leq_trans (s x) y (s y) h t; }; 
  have v:Ï€ (istrue (s x â‰¤ x)) { apply leq_trans (s x) (s y) x u i; };
  apply leqsnn x; apply v;
end;

// < is antisymmetric
opaque symbol anti_ltn x y : Ï€ (istrue (x < y)) â†’ Ï€ (istrue (y < x)) â†’ Ï€ (x = y) â‰”
begin
  simplify;
  assume x y h i;
  have c:Ï€ (istrue (x â‰¤ s x)) { apply leqnSn x; };
  have d:Ï€ (istrue (y â‰¤ s y)) { apply leqnSn y; };
  have e:Ï€ (istrue (x â‰¤ y)) { apply leq_trans x (s x) y c h; };
  have f:Ï€ (istrue (y â‰¤ x)) { apply leq_trans y (s y) x d i; };
  have g:Ï€ (istrue (x â‰¤ y) âˆ§ istrue (y â‰¤ x)) { apply âˆ§áµ¢ _ _ e f; }; 
  apply âˆ§â‚‘â‚  _ _ (eqn_leq x y) g;
end;

// â‰¤ is total
opaque symbol leq_total x y : Ï€ (istrue (x â‰¤ y) âˆ¨ istrue (y â‰¤ x)) â‰”
begin
  induction
  { assume y; simplify; apply âˆ¨áµ¢â‚ _ _; apply top; }
  { assume x h;
    induction
    { simplify; apply âˆ¨áµ¢â‚‚ _ _; apply top; }
    { assume y i; simplify; apply h y; }
  }
end;

opaque symbol lt0n n : Ï€ (istrue (n > 0) â‡” (n â‰  0)) â‰”
begin
  assume n;
  apply âˆ§áµ¢ {
    generalize n;
    induction
    { simplify; assume h i; apply h; }
    { assume n; simplify; assume h i j; apply snâ‰ 0 n j;}
  } {
    generalize n;
    induction
    { simplify; assume h; apply h (eq_refl 0); }
    { assume n; simplify;  assume h i; apply top; }
  };
end;

//Equivalence
opaque symbol leq_eqVlt m n : Ï€ (istrue (m â‰¤ n) â‡” (m = n) âˆ¨ istrue (m < n)) â‰”
begin
  assume m n;
  apply âˆ§áµ¢ {
    generalize m;
    induction
    { induction
      { simplify; assume h; apply âˆ¨áµ¢â‚ _ _ (eq_refl 0); }
      { assume n h; simplify; assume i; apply âˆ¨áµ¢â‚‚ _ _ top; }
    }
    { assume m h;
      induction
      { simplify; assume i; apply âˆ¨áµ¢â‚‚ _ _ i; }
      { assume n i; simplify; assume j; admit;}
    }
  } {
    assume h;
    apply âˆ¨â‚‘ (m = n) (istrue (m < n)) (istrue (m â‰¤ n)) h {
      assume i; apply eq_leq m n i; 
    } {
      assume i; apply ltnW m n i;
    };
  };
abort;

opaque symbol ltn_neqAle m n : Ï€ (istrue (m < n) â‡” istrue (m â‰¤ n) âˆ§ (m â‰  n)) â‰”
begin
abort;

opaque symbol leq_add0 m n : Ï€ (istrue (0 â‰¤ m)) â†’ Ï€ (istrue (0 â‰¤ n)) â†’ Ï€ (istrue (0 â‰¤ m + n)) â‰”
begin
  assume m n h i; apply leq0n (m + n);
end;

opaque symbol leq_add2l p m n : Ï€ (istrue (p + m â‰¤ p + n) â‡” istrue (m â‰¤ n)) â‰”
begin
  assume p m n;
  apply âˆ§áµ¢ {
    generalize m; generalize p;
    induction
    { assume m n; simplify; assume h; apply h; }
    { assume p h m n; simplify; assume i; apply h m n i; }
  } {
    generalize m; generalize p; 
    induction
    { assume m n; simplify; assume h; apply h; }
    { assume p h m n; simplify; assume i; apply h m n i; }
  }; 
end;

opaque symbol ltn_add2l p m n : Ï€ (istrue (p + m < p + n) â‡” istrue (m < n)) â‰”
begin
  assume p m n; simplify; rewrite left addnS; refine leq_add2l p (s m) n;
end;

opaque symbol leq_add2r p m n : Ï€ (istrue (m + p â‰¤ n + p) â‡” istrue (m â‰¤ n)) â‰”
begin
  assume p m n; rewrite addnC m p; rewrite addnC n p; refine leq_add2l p m n; 
end;

opaque symbol ltn_add2r p m n : Ï€ (istrue (m + p < n + p) â‡” istrue (m < n)) â‰”
begin
  assume p m n; rewrite addnC m p; rewrite addnC n p; refine ltn_add2l p m n; 
end;

opaque symbol leq_addl m n : Ï€ (istrue (n â‰¤ m + n)) â‰”
begin
  assume m;
  induction
  { simplify; apply top; }
  { assume n; simplify; assume h; apply h; }
end;

opaque symbol leq_addr m n : Ï€ (istrue (n â‰¤ n + m)) â‰”
begin
  assume m n; rewrite addnC n m; apply leq_addl m n;
end;

opaque symbol leq_subr m n : Ï€ (istrue (n - m â‰¤ n)) â‰”
begin
  induction
  { assume n; simplify; apply â‰¤_refl n; }
  { assume m h;
    induction
    { simplify; apply top; }
    { assume n i; simplify; 
      have t: Ï€ (istrue (n â‰¤ s n)) { apply leqnSn n;};
      apply leq_trans (n - m) n (s n) (h n) t;
    }
  }
end;

opaque symbol subn_eq0 m n : Ï€ ((m - n = 0) â‡” istrue (m â‰¤ n)) â‰”
begin
  assume m n;
  apply âˆ§áµ¢ {
    generalize m;
    induction
    { assume n; simplify; assume h; apply top; }
    { assume m h;
      induction
      { simplify; assume i; apply snâ‰ 0 m; apply i; }
      { assume n i; simplify; assume j; apply h n j; }
    }
  } {
    generalize m;
    induction
    { assume n h; simplify; apply eq_refl 0; }
    { assume m h;
      induction
      { simplify; assume i; apply âŠ¥â‚‘; apply i; }
      { assume n i; simplify; assume j; apply h n j; }
    }
  };
end;

opaque symbol ltn_addl m n p : Ï€ (istrue (m < n)) â†’ Ï€ (istrue (m < p + n)) â‰”
begin
  assume m n;
  induction
  { assume h; simplify; apply h; }
  { assume p; simplify; assume h i;
    refine leq_trans m (s m) (p + n) (leqnSn m) (h i);
  }
end;

opaque symbol ltn_addr m n p : Ï€ (istrue (m < n)) â†’ Ï€ (istrue (m < n + p)) â‰”
begin
  assume m n p h; rewrite addnC n p; apply ltn_addl m n p; apply h;
end; 

opaque symbol addn_gt0 m n : Ï€ (istrue (0 < m + n) â‡” istrue (0 < m) âˆ¨ istrue (0 < n)) â‰”
begin
  assume m n;
  apply âˆ§áµ¢ {
    generalize m; induction
    { assume n i; apply âˆ¨áµ¢â‚‚ (istrue (0 < 0)) (istrue (0 < n)); apply i; }
    { assume m h n i; apply âˆ¨áµ¢â‚ (istrue (0 < s m)) (istrue (0 < n)); apply ltn0Sn m; }
  } {
    assume h;
    apply âˆ¨â‚‘ (istrue (0 < m)) (istrue (0 < n)) (istrue (0 < m + n)) h {
      assume i; apply ltn_addr 0 m n i;
    } {
      assume i; apply ltn_addl 0 n m i;
    };
  };
end;

opaque symbol subn_gt0 m n : Ï€ (istrue (0 < n - m) â‡” istrue (m < n)) â‰”
begin
  assume m n;
  apply âˆ§áµ¢ {
    generalize m;
    induction
    { assume n; simplify; assume h; apply h; }
    { assume m h;
      induction
      { simplify; assume i; apply i; }
      { assume n i; rewrite subSS; assume j; 
        have t: Ï€ (istrue (m < n)) { apply h n j; };
        have u: Ï€ (istrue (m + 1 < n + 1)) { refine âˆ§â‚‘â‚‚ _ _ (ltn_add2r 1 m n) t; };
        rewrite left addn1 m; rewrite left addn1 n; apply u;
      }
    }
  } {
    generalize m;  
    induction
    { assume n; simplify; assume h; apply h; }
    { assume m h;
      induction
      { simplify; assume i; apply i; }
      { assume n i; assume j; rewrite subSS; apply h n;
        refine âˆ§â‚‘â‚ _ _ (ltn_add2r 1 m n) j;
      }
    }
  };
end;

opaque symbol leq_add m1 m2 n1 n2 : Ï€ (istrue (m1 â‰¤ n1)) â†’ Ï€ (istrue (m2 â‰¤ n2)) â†’ Ï€ (istrue (m1 + m2 â‰¤ n1 + n2)) â‰”
begin
  assume m1 m2 n1 n2 h i;
  have a: Ï€ (istrue (m1 + m2 â‰¤ m1 + n2)) { apply âˆ§â‚‘â‚‚ _ _ (leq_add2l m1 m2 n2) i; };
  have b: Ï€ (istrue (m1 + n2 â‰¤ n1 + n2)) { refine âˆ§â‚‘â‚‚ _ _ (leq_add2r n2 m1 n1) h; };
  refine leq_trans (m1 + m2) (m1 + n2) (n1 + n2) a b;
end;

opaque symbol leq_subLR m n p : Ï€ (istrue (m - n â‰¤ p) â‡” istrue (m â‰¤ n + p)) â‰”
begin
  assume m n p;
  apply âˆ§áµ¢ 
  { assume h;
    have t: Ï€ (((m - (n + p)) = 0)) â†’ Ï€ (istrue (m â‰¤ (n + p))) { apply âˆ§â‚‘â‚ _ _ (subn_eq0 m (n + p)); }; apply t;
    rewrite subnDA;
    apply âˆ§â‚‘â‚‚ _ _ (subn_eq0 (m - n) p) h;
  } { assume h; 
    have t: Ï€ (((m - n) - p) = 0) â†’ Ï€ (istrue ((m - n) â‰¤ p)) { apply âˆ§â‚‘â‚ _ _ (subn_eq0 (m - n) p); }; apply t;
    rewrite left subnDA;
    apply âˆ§â‚‘â‚‚ _ _ (subn_eq0 m (n + p)) h;
  };
end;

opaque symbol subnKC m n : Ï€ (istrue (m â‰¤ n)) â†’ Ï€ (m + (n - m) = n) â‰”
begin
  induction
  { assume n h; simplify; apply eq_refl n; }
  { assume m h;
    induction
    { simplify; assume i; apply âŠ¥â‚‘; apply i; }
    { assume n i; simplify; assume j; apply feq s; apply h; apply j; }
  }
end;

opaque symbol addnBn m n : Ï€ (m + (n - m) = m - n + n) â‰”
begin
  induction
  { assume n; simplify; apply eq_refl n; }
  { assume m h;
    induction
    { simplify; apply eq_refl (s m); }
    { assume n i; simplify; apply feq s; apply h n; }
  }
end;

opaque symbol subnK m n : Ï€ (istrue (m â‰¤ n)) â†’ Ï€ ((n - m) + m = n) â‰”
begin
  assume m n h;
  rewrite addnC;
  apply subnKC m n h;
end;

opaque symbol subSn n p : Ï€ (istrue (p â‰¤ n)) â†’ Ï€ (s n - p = s (n - p)) â‰”
begin
  induction
  { assume p h; simplify;
    have t: Ï€ (p = 0) { apply â‰¤0 p h; };
    rewrite t; reflexivity; 
  }
  { assume n h;
    induction
    { assume i; reflexivity; }
    { assume p i; simplify; assume j; apply h p j }
  }
end;

opaque symbol addnBA m n p : Ï€ (istrue (p â‰¤ n))  â†’ Ï€ (m + (n - p) = m + n - p) â‰”
begin
  induction
  { assume n p h; reflexivity; }
  { assume m h n p i; simplify; rewrite left addnS m (n - p); rewrite left addnS m n;
    rewrite left h (s n) p (leqW p n i); rewrite subSn n p i; reflexivity; 
  }
end;

opaque symbol addnBAC m n p : Ï€ (istrue (n â‰¤ m)) â†’ Ï€ (m - n + p = m + p - n) â‰”
begin
  assume m n p h;
  rewrite addnC; rewrite addnBA p m n h; rewrite addnC;
  reflexivity;
end;

opaque symbol leq_sub2r m n p : Ï€ (istrue (m â‰¤ n)) â†’ Ï€ (istrue (m - p â‰¤ n - p)) â‰”
begin
  assume m n p h;
  apply âˆ§â‚‘â‚‚ _ _ (leq_subLR m p (n - p)) _;
  apply âˆ¨â‚‘ _ _ _ (leq_total p n) {
    assume i; rewrite subnKC p n i; apply h;
  } {
    assume i; 
    have t:Ï€ (n - p = 0) { apply (â‡”â‚‘â‚‘ _ _ i (subn_eq0 n p)) };
    rewrite t; simplify;
    apply leq_trans m n p h i;
  };
end;

opaque symbol leq_sub2l m n p : Ï€ (istrue (m â‰¤ n)) â†’ Ï€ (istrue (p - n â‰¤ p - m)) â‰”
begin
  assume m n p h;
  apply âˆ§â‚‘â‚‚ _ _ (leq_subLR p n (p - m)) _;
  apply âˆ¨â‚‘ _ _ _ (leq_total p m) {
    assume i;
    have t:Ï€ (p - m = 0) { apply (â‡”â‚‘â‚‘ _ _ i (subn_eq0 p m)) };
    rewrite t; simplify;
    apply leq_trans p m n i h;
  } {
    assume i;
    apply âˆ§â‚‘â‚ _ _ (leq_add2r m p (n + (p - m))) _;
    rewrite addnA; rewrite subnK m p i; rewrite addnC n p;
    apply âˆ§â‚‘â‚‚ _ _ (leq_add2l p m n) h;
  };
end;

opaque symbol leq_sub m1 m2 n1 n2 : Ï€ (istrue (m1 â‰¤ m2)) â†’ Ï€ (istrue (n2 â‰¤ n1)) â†’ Ï€ (istrue (m1 - n1 â‰¤ m2 - n2)) â‰”
begin
  assume m1 m2 n1 n2 h i;
  have t:Ï€ (istrue (m1 - n1 â‰¤ m2 - n1)) { apply leq_sub2r m1 m2 n1 h; };
  have u:Ï€ (istrue (m2 - n1 â‰¤ m2 - n2)) { apply leq_sub2l n2 n1 m2 i; };
  apply leq_trans (m1 - n1) (m2 - n1) (m2 - n2) t u;
end;

/************************************
*************** Maximum *************
*************************************/

symbol max: â„• â†’ â„• â†’ â„•;

//notation max prefix 40;

rule max 0 $x â†ª $x
with max $x 0 â†ª $x
with max (s $x) (s $y) â†ª s (max $x $y);

opaque symbol maxnC x y : Ï€ (max x y = max y x) â‰”
begin
  induction
  { reflexivity }
  { assume x h; simplify; induction
    { reflexivity }
    { assume y i; simplify; rewrite h; reflexivity }
  }
end;

opaque symbol maxnA x y z : Ï€ (max (max x y) z = max x (max y z)) â‰”
begin
  induction
  { reflexivity }
  { assume x h; induction
    { reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; simplify; rewrite h; reflexivity }
    }
  }
end;

opaque symbol maxnAC x y z : Ï€ (max (max x y) z = max (max x z) y) â‰”
begin
  assume x y z; rewrite maxnA; rewrite maxnC y z; rewrite left maxnA; reflexivity;
end;

opaque symbol maxnCA x y z : Ï€ (max x (max y z) = max y (max x z)) â‰”
begin
  assume x y z; rewrite left maxnA; rewrite maxnC x y; rewrite maxnA; reflexivity; 
end;

opaque symbol maxnACA x y z t: Ï€ (max (max x y) (max z t) = max (max x z) (max y t)) â‰”
begin
  assume x y z t; rewrite maxnA; rewrite maxnC y (max z t); rewrite maxnA; rewrite left maxnA x z; rewrite maxnC t y; reflexivity;
end;

opaque symbol addn_maxl x y z: Ï€ ((max y z) + x = max (y + x) (z + x)) â‰”
begin
  induction
  { reflexivity; }
  { assume x h y z; simplify; apply feq s; rewrite h; reflexivity;}
end;

opaque symbol addn_maxr x y z : Ï€ (x + (max y z) = max (x + y) (x + z)) â‰”
begin
  induction
  { reflexivity }
  { assume x h y z; simplify; apply feq s; rewrite h; reflexivity }
end;

opaque symbol subn_maxl x y z: Ï€ ( (max x y) - z = max (x - z) (y - z) ) â‰”
begin
  induction
  { assume y z; simplify; reflexivity; }
  { assume x h;
    induction
    { assume z; simplify; reflexivity; }
    { assume y i; simplify; 
      induction
      { simplify; reflexivity; }
      { assume z j; simplify; apply h y z; }
    }
  }
end;

opaque symbol maxnE m n : Ï€ (max m n = m + (n - m)) â‰”
begin
  induction
  { assume n; simplify; reflexivity; }
  { assume m h;
    induction
    { simplify;  reflexivity; }
    { assume n i; simplify; rewrite h; reflexivity; }
  }
end;

//Idempotent
opaque symbol maxnn x : Ï€ (max x x = x) â‰”
begin
  induction
  { simplify; reflexivity; }
  { assume x h; simplify; rewrite h; reflexivity; }
end;

rule max $x $x â†ª $x;

//Inegalities
opaque symbol leq_maxl m n : Ï€ (istrue (m â‰¤ max m n)) â‰”
begin
  induction
  { assume n; simplify; apply top; }
  { assume m h;
    induction
    { simplify; apply â‰¤_refl m; }
    { assume n i; simplify; apply h n;}
  }
end;

opaque symbol leq_maxr m n : Ï€ (istrue (n â‰¤ max m n)) â‰”
begin
  assume m n; rewrite maxnC m n; apply leq_maxl n m;
end;

opaque symbol gtn_max m n1 n2 : Ï€ (istrue (m > max n1 n2) â‡” istrue (m > n1) âˆ§ istrue (m > n2)) â‰”
begin
abort;

opaque symbol geq_max m n1 n2 : Ï€ (istrue (m â‰¥ max n1 n2) â‡” istrue (m â‰¥ n1) âˆ§ istrue (m â‰¥ n2)) â‰”
begin
abort;

opaque symbol ltn_predK m n : Ï€ (istrue (m < n)) â†’ Ï€ (s (p n) = n) â‰”
begin
  assume m;
  induction
  { simplify; assume h; refine âŠ¥â‚‘ _ h; }
  { assume n h i; simplify; reflexivity; }
end;

opaque symbol prednK n : Ï€ (istrue (0 < n)) â†’ Ï€ (s (p n) = n) â‰”
begin
  refine ltn_predK 0; 
end;

opaque symbol leq_pmull m n : Ï€ (istrue (n > 0)) â†’ Ï€ (istrue (m â‰¤ n Ã— m)) â‰”
begin
  assume m n h; 
  have t: Ï€ (s (p n) = n) { apply prednK n h; };
  rewrite left t; simplify; apply leq_addr (p n Ã— m) m; 
end;

opaque symbol leq_pmulr m n : Ï€ (istrue (n > 0)) â†’ Ï€ (istrue (m â‰¤ m Ã— n)) â‰”
begin
  assume m n h; rewrite mulnC; apply leq_pmull m n h; 
end; 

opaque symbol leq_mul2l m n1 n2 : Ï€ (istrue (m Ã— n1 â‰¤ m Ã— n2) â‡” (m = 0) âˆ¨ istrue (n1 â‰¤ n2)) â‰”
begin
  assume m n1 n2;
  apply âˆ§áµ¢ { 
    assume h;
    have t:Ï€ (m Ã— (n1 - n2) = 0) {
      rewrite mulnBr;
      apply â‡”â‚‘â‚‘ _ _ _ (subn_eq0 (m Ã— n1) (m Ã— n2));
      apply h;
    };
    have u: Ï€ ((m = 0) âˆ¨ (n1 - n2 = 0)) { apply âˆ§â‚‘â‚ _ _ (muln_eq0 m (n1 - n2)) t; };
    apply âˆ¨â‚‘ _ _ _ u _ _ {
      assume i; refine âˆ¨áµ¢â‚ _ _ i; 
    } {
      assume i; refine âˆ¨áµ¢â‚‚ _ _ _; apply âˆ§â‚‘â‚ _ _ (subn_eq0 n1 n2) i; 
    }; 
  } { 
    assume h; 
    apply â‡”â‚‘ _ _ _ (subn_eq0 (m Ã— n1) (m Ã— n2));
    rewrite left mulnBr;
    apply âˆ¨â‚‘ _ _ _ h _ _ { 
      assume i; rewrite i; reflexivity; 
    } {
      assume i;
      have t:Ï€ (n1 - n2 = 0) { apply âˆ§â‚‘â‚‚ _ _ (subn_eq0 n1 n2) i; };
      rewrite t; reflexivity;
    };
  }
end;

opaque symbol leq_mul2r m n1 n2 : Ï€ (istrue (n1 Ã— m â‰¤ n2 Ã— m) â‡” (m = 0) âˆ¨ (istrue (n1 â‰¤ n2))) â‰”
begin
  assume m n1 n2; rewrite mulnC n1 m; rewrite mulnC n2 m; refine leq_mul2l m n1 n2; 
end;

opaque symbol leq_mul m1 m2 n1 n2 : Ï€ (istrue (m1 â‰¤ n1)) â†’ Ï€ (istrue (m2 â‰¤ n2)) â†’ Ï€ (istrue (m1 Ã— m2 â‰¤ n1 Ã— n2)) â‰”
begin
  assume m1 m2 n1 n2 h1 h2;
  have t1:Ï€ ((m2 = 0) âˆ¨ istrue (m1 â‰¤ n1)) { apply âˆ¨áµ¢â‚‚ _ _ h1; };
  have t2:Ï€ ((n1 = 0) âˆ¨ istrue (m2 â‰¤ n2)) { apply âˆ¨áµ¢â‚‚ _ _ h2; };
  have u1:Ï€ (istrue (m1 Ã— m2 â‰¤ n1 Ã— m2)) { refine â‡”â‚‘â‚‘ _ _ t1 (leq_mul2r m2 m1 n1); };
  have u2:Ï€ (istrue (n1 Ã— m2 â‰¤ n1 Ã— n2)) { refine â‡”â‚‘â‚‘ _ _ t2 (leq_mul2l n1 m2 n2); }; 
  apply leq_trans (m1 Ã— m2) (n1 Ã— m2) (n1 Ã— n2) u1 u2;
end;

opaque symbol eqn_mul2l m n1 n2 : Ï€ (m Ã— n1 = m Ã— n2 â‡” (m = 0) âˆ¨ (n1 = n2)) â‰”
begin
  assume m n1 n2;
  apply âˆ§áµ¢ {
    assume h;
    type eqn_leq;
    have t:Ï€ (istrue (m Ã— n1 â‰¤ m Ã— n2) âˆ§ istrue (m Ã— n2 â‰¤ m Ã— n1)) { apply â‡”â‚‘â‚‘ _ _ h (eqn_leq (m Ã— n1) (m Ã— n2)); };
    have t1:Ï€ (istrue (m Ã— n1 â‰¤ m Ã— n2)) { apply âˆ§â‚‘â‚ _ _ t; };
    have t2:Ï€ (istrue (m Ã— n2 â‰¤ m Ã— n1)) { apply âˆ§â‚‘â‚‚  _ _ t; };
    have u1: Ï€ ((m = 0) âˆ¨ istrue (n1 â‰¤ n2)) { apply â‡”â‚‘ _ _ t1 (leq_mul2l m n1 n2); };
    have u2: Ï€ ((m = 0) âˆ¨ istrue (n2 â‰¤ n1)) { apply â‡”â‚‘ _ _ t2 (leq_mul2l m n2 n1); };
    apply âˆ¨â‚‘ _ _ _ u1 {
      assume i; apply âˆ¨áµ¢â‚ _ _ i;
    } {
      assume i; 
      apply âˆ¨â‚‘ _ _ _ u2 {
        assume j; apply âˆ¨áµ¢â‚ _ _ j;
      } {
        assume j; apply âˆ¨áµ¢â‚‚ _ _ _;
        apply âˆ§â‚‘â‚ _ _ (eqn_leq n1 n2) (âˆ§áµ¢ _ _ i j);
      };
    };
  } {
    assume h;
    apply âˆ¨â‚‘ _ _ _ h {
      assume i; rewrite i; reflexivity;
    } {
      assume i; rewrite i; reflexivity;
    };
  };
end;

opaque symbol eqn_mul2r m n1 n2 : Ï€ ((n1 Ã— m = n2 Ã— m) â‡” (m = 0) âˆ¨ (n1 = n2)) â‰”
begin
  assume m n1 n2; rewrite mulnC n1 m; rewrite mulnC n2 m; refine eqn_mul2l m n1 n2;
end;

opaque symbol leq_pmul2l m n1 n2 : Ï€ (istrue (0 < m)) â†’ Ï€ (istrue (m Ã— n1 â‰¤ m Ã— n2) â‡” istrue (n1 â‰¤ n2)) â‰”
begin
  assume m n1 n2 h;
  apply âˆ§áµ¢ {
    assume i;
    have t: Ï€ ((m = 0) âˆ¨ istrue (n1 â‰¤ n2)) { apply âˆ§â‚‘â‚ _ _ (leq_mul2l m n1 n2) i; };
    apply âˆ¨â‚‘ (m = 0) (istrue (n1 â‰¤ n2)) _ t _ _ {
      assume j;
      have u: Ï€ (istrue (0 < 0)) { rewrite left .[m in (istrue (_ < m))] j; apply h; };
      refine âŠ¥â‚‘ _ u;
    } {
      assume j; apply j;
    };
  } {
    assume i;
    refine â‡”â‚‘â‚‘ _ _ _ (leq_mul2l m n1 n2);
    refine âˆ¨áµ¢â‚‚ _ _ i; 
  };
end;

opaque symbol leq_pmul2r m n1 n2 : Ï€ (istrue (0 < m)) â†’ Ï€ (istrue (n1 Ã— m â‰¤ n2 Ã— m) â‡” istrue (n1 â‰¤ n2)) â‰”
begin
  assume m n1 n2 h; rewrite mulnC n1 m; rewrite mulnC n2 m; refine leq_pmul2l m n1 n2 h;
end;

opaque symbol ltn0_neq0 m : Ï€ (istrue (0 < m) â‡” m â‰  0) â‰”
begin
  assume m;
  apply âˆ§áµ¢ {
    generalize m;
    induction
    { simplify; assume h i; apply h; }
    { assume m h; simplify; assume i j; apply snâ‰ 0 m j;}
  } {
    generalize m;
    induction
    { simplify; assume h; apply h (eq_refl 0); }
    { assume m h i; simplify; apply top; }
  };
end;

opaque symbol disj0 m : Ï€ (m = 0 âˆ¨ m â‰  0) â‰”
begin
  induction
  { apply âˆ¨áµ¢â‚ _ _ (eq_refl 0); }
  { assume m h; apply âˆ¨áµ¢â‚‚ _ _ _; simplify; assume i; apply snâ‰ 0 m i; }
end;

opaque symbol eqn_pmul2l m n1 n2 : Ï€ (istrue (0 < m)) â†’ Ï€ (m Ã— n1 = m Ã— n2 â‡” n1 = n2) â‰”
begin
  assume m n1 n2 h;
  apply âˆ§áµ¢ {
    assume i1;
    have i2: Ï€ (m Ã— n2 = m Ã— n1) { symmetry; apply i1; };
    have v1: Ï€ (istrue (m Ã— n1 â‰¤ m Ã— n2)) { apply eq_leq _ _ i1; };
    have v2: Ï€ (istrue (m Ã— n2 â‰¤ m Ã— n1)) { apply eq_leq _ _ i2; };
    have w1: Ï€ (istrue (n1 â‰¤ n2)) { apply â‡”â‚‘ _ _ v1 (leq_pmul2l m n1 n2 h); };
    have w2: Ï€ (istrue (n2 â‰¤ n1)) { apply â‡”â‚‘ _ _ v2 (leq_pmul2l m n2 n1 h); };
    apply âˆ§â‚‘â‚ _ _ (eqn_leq n1 n2) (âˆ§áµ¢ _ _ w1 w2);
  } {
    assume i;
    have t:Ï€ (m = 0 âˆ¨ n1 = n2) { apply âˆ¨áµ¢â‚‚ (m = 0) (n1 = n2) i; };
    apply â‡”â‚‘â‚‘ _ _ t (eqn_mul2l m n1 n2) ;
  };
end;

opaque symbol eqn_pmul2r m n1 n2 : Ï€ (istrue (0 < m)) â†’ Ï€ (n1 Ã— m = n2 Ã— m â‡” n1 = n2) â‰”
begin
  assume m n1 n2 h; rewrite mulnC n1 m; rewrite mulnC n2 m; apply eqn_pmul2l m n1 n2 h; 
end;

/************************************
*************** Minimum *************
*************************************/
symbol min : â„• â†’ â„• â†’ â„•;

//notation min prefix 40;

rule min 0 $x â†ª 0
with min $x 0 â†ª 0
with min (s $x) (s $y) â†ª s (min $x $y);

opaque symbol minnC x y : Ï€ (min x y = min y x) â‰”
begin
  induction
  { reflexivity }
  { assume x h; simplify; 
    induction
    { reflexivity }
    { assume y i; simplify; rewrite h; reflexivity;}
  }
end;

opaque symbol minnA x y z : Ï€ (min (min x y) z = min x (min y z)) â‰”
begin
  induction
  { reflexivity }
  { assume x h; simplify; 
    induction
    { reflexivity }
    { assume y i; simplify; 
      induction
      { reflexivity }
      { assume z j; simplify; rewrite h; reflexivity;}
    }
  }
end;

opaque symbol minnAC x y z : Ï€ (min (min x y) z = min (min x z) y) â‰”
begin
  assume x y z; rewrite minnA; rewrite minnC y z; rewrite left minnA; reflexivity;
end;

opaque symbol minnCA x y z : Ï€ (min x (min y z) = min y (min x z)) â‰”
begin
  assume x y z; rewrite left minnA; rewrite minnC x y; rewrite minnA; reflexivity; 
end;

opaque symbol minnACA x y z t: Ï€ (min (min x y) (min z t) = min (min x z) (min y t)) â‰”
begin
  assume x y z t; rewrite minnA; rewrite minnC y (min z t); rewrite minnA; rewrite left minnA x z; rewrite minnC t y; reflexivity;
end;

opaque symbol addn_minl x y z: Ï€ ((min y z) + x = min (y + x) (z + x)) â‰”
begin
  induction
  { reflexivity; }
  { assume x h y z; simplify; apply feq s; rewrite h; reflexivity;}
end;

opaque symbol addn_minr x y z: Ï€ (x + (min y z) = min (x + y) (x + z)) â‰”
begin
  induction
  { reflexivity; }
  { assume x h y z; simplify; apply feq s; rewrite h; reflexivity;}
end;

opaque symbol subn_minl x y z: Ï€ ((min x y) - z = min (x - z) (y - z)) â‰”
begin
  induction
  { assume y z; simplify; reflexivity; }
  { assume x h;
    induction
    { assume z; simplify; reflexivity; }
    { assume y i; simplify; 
      induction
      { simplify; reflexivity; }
      { assume z j; simplify; apply h y z; }
    }
  }
end;

opaque symbol minnE m n : Ï€ (min m n = m - (m - n)) â‰”
begin
  induction
  { reflexivity; }
  { assume m h; 
    induction
    { reflexivity; }
    { assume n i; simplify; rewrite h; }
  }
abort;

//Idempotent
opaque symbol minnn x : Ï€ (min x x = x) â‰”
begin
  induction
  { simplify; reflexivity;}
  { assume x h; simplify; rewrite h; reflexivity; }
end;

rule min $x $x â†ª $x;

//Inegalities
opaque symbol geq_minl m n : Ï€ (istrue (min m n â‰¤ m)) â‰”
begin
  induction
  { assume n; simplify; apply top; }
  { assume m h; 
    induction
    { simplify; apply top; }
    { assume n i; simplify; apply h n; }
  }
end;

opaque symbol geq_minr m n : Ï€ (istrue (min m n â‰¤ n)) â‰”
begin
  assume m n; rewrite minnC; apply geq_minl n m;
end;

//Proofs on max and min
opaque symbol addn_min_max m n : Ï€ (min m n + max m n = m + n) â‰”
begin
  induction
  { assume m; simplify; reflexivity; }
  { assume m h; 
    induction
    { simplify; reflexivity; }
    { assume n i; simplify; rewrite h n; reflexivity; }
  }
end;

opaque symbol maxnK m n : Ï€ (min (max m n) m = m) â‰”
begin
  induction
  { assume n; simplify; reflexivity; }
  { assume m h;
    induction
    { simplify; reflexivity; }
    { assume n i; simplify;  rewrite h n; reflexivity; }
  }
end;

opaque symbol maxKn m n : Ï€ (min n (max m n) = n) â‰”
begin
  induction
  { assume n; simplify; reflexivity; }
  { assume m h; 
    induction
    { simplify; reflexivity; }
    { assume n i; simplify; rewrite h n; reflexivity; }
  }
end;

opaque symbol minnK m n : Ï€ (max (min m n) m = m) â‰”
begin
  induction
  { assume n; simplify; reflexivity; }
  { assume m h; 
    induction
    { simplify; reflexivity; }
    { assume n i; simplify;  rewrite h n; reflexivity; }
  }
end;

opaque symbol minKn m n : Ï€ (max n (min m n) = n) â‰”
begin
  induction
  { assume n; simplify; reflexivity; }
  { assume m h; 
    induction
    { simplify; reflexivity; }
    { assume n i; simplify;  rewrite h n; reflexivity; }
  }
end;

//Distributivity
opaque symbol maxn_minl x y z : Ï€ (max x (min y z) = min (max x y) (max x z)) â‰”
begin
  induction
  { assume y z; simplify; reflexivity; }
  { assume x h;
    induction
    { assume z; simplify; rewrite minnC; rewrite maxnK (s x) z; reflexivity; }
    { assume y i;
      induction
      { simplify; rewrite maxnK x y; reflexivity; }
      { assume z j; simplify; rewrite h; reflexivity; }
    }
  }
end;

opaque symbol maxn_minr x y z : Ï€ (max (min y z) x = min (max y x) (max z x)) â‰”
begin
  induction
  { assume y z; simplify; reflexivity; }
  { assume x h;
    induction
    { assume z; simplify; rewrite maxKn z (s x); reflexivity; }
    { assume y i;
      induction
      { simplify; rewrite maxnC; rewrite maxnK x y; reflexivity; }
      { assume z j; simplify; rewrite h; reflexivity; }
    }
  }
end;

opaque symbol minn_maxl x y z : Ï€ (min x (max y z) = max (min x y) (min x z)) â‰”
begin
  induction
  { assume y z; simplify; reflexivity; }
  { assume x h;
    induction
    { assume z; simplify; reflexivity; }
    { assume y i;
      induction
      { simplify; reflexivity; }
      { assume z j; simplify; rewrite h; reflexivity; }
    }
  }
end;

opaque symbol minn_maxr x y z : Ï€ (min (max y z) x = max (min y x) (min z x)) â‰”
begin
  induction
  { assume y z; simplify; reflexivity; }
  { assume x h;
    induction
    { assume z; simplify; reflexivity; }
    { assume y i;
      induction
      { simplify; reflexivity; }
      { assume z j; simplify; rewrite h; reflexivity; }
    }
  }
end;

opaque symbol maxnMr x y z : Ï€ ((max y z) Ã— x = max (y Ã— x) (z Ã— x)) â‰”
begin
  induction
  { assume y z; simplify; reflexivity; }
  { assume x h;
    induction
    { assume z; simplify; reflexivity; }
    { assume y i;
      induction
      { simplify; reflexivity; }
      { assume z j; rewrite left addn1 y; rewrite left addn1 z; 
        rewrite left addn_maxl 1 y z; symmetry; 
        rewrite mulnDl y 1 (s x); rewrite mulnDl z 1 (s x); 
        rewrite left addn_maxl (1 Ã— s x) (y Ã— s x) (z Ã— s x); rewrite left i; 
        symmetry; rewrite mulnDl (max y z) 1 (s x); reflexivity;
      }
    }
  }
end;

opaque symbol maxnMl x y z : Ï€ (x Ã— (max y z) = max (x Ã— y) (x Ã— z)) â‰”
begin
  induction
  { assume y z; simplify; reflexivity; }
  { assume x h;
    induction
    { assume z; simplify; reflexivity; }
    { assume y i;
      induction
      { simplify; reflexivity; }
      { assume z j; rewrite left addn1 y; rewrite left addn1 z; 
        rewrite left addn_maxl 1 y z; symmetry; 
        rewrite mulnDr y 1 (s x); rewrite mulnDr z 1 (s x); 
        rewrite left addn_maxl (s x Ã— 1) (s x Ã— y) (s x Ã— z); rewrite left i; 
        symmetry; rewrite mulnDr (max y z) 1 (s x); reflexivity;
      }
    }
  }
end;

opaque symbol minnMr x y z : Ï€ ((min y z) Ã— x = min (y Ã— x) (z Ã— x)) â‰”
begin
  induction
  { assume y z; simplify; reflexivity; }
  { assume x h;
    induction
    { assume z; simplify; reflexivity; }
    { assume y i;
      induction
      { simplify; reflexivity; }
      { assume z j; rewrite left addn1 y; rewrite left addn1 z; 
        rewrite left addn_minl 1 y z; symmetry; 
        rewrite mulnDl y 1 (s x); rewrite mulnDl z 1 (s x); 
        rewrite left addn_minl (1 Ã— s x) (y Ã— s x) (z Ã— s x); rewrite left i; 
        symmetry; rewrite mulnDl (min y z) 1 (s x); reflexivity;
      }
    }
  }
end;

opaque symbol minnMl x y z : Ï€ (x Ã— (min y z) = min (x Ã— y) (x Ã— z)) â‰”
begin
  induction
  { assume y z; simplify; reflexivity; }
  { assume x h;
    induction
    { assume z; simplify; reflexivity; }
    { assume y i;
      induction
      { simplify; reflexivity; }
      { assume z j; rewrite left addn1 y; rewrite left addn1 z; 
        rewrite left addn_minl 1 y z; symmetry; 
        rewrite mulnDr y 1 (s x); rewrite mulnDr z 1 (s x); 
        rewrite left addn_minl (s x Ã— 1) (s x Ã— y) (s x Ã— z); rewrite left i; 
        symmetry; rewrite mulnDr (min y z) 1 (s x); reflexivity;
      }
    }
  }
end;

/************************************
********** Exponentiation ***********
*************************************/

symbol ^ : â„• â†’ â„• â†’ â„•;

notation ^ infix left 40;

rule $n ^ 0 â†ª 1
with $n ^ (s $m) â†ª $n Ã— $n ^ $m;

opaque symbol expn0 m : Ï€ (m ^ 0 = 1) â‰”
begin
  assume m; reflexivity;
end;

opaque symbol expn m : Ï€ (m ^ 1 = m) â‰”
begin
  assume m; reflexivity;
end;

opaque symbol expnS a n : Ï€ (a ^ s n = a Ã— a ^ n ) â‰”
begin
  assume a;
  induction
  { simplify; reflexivity; }
  { assume n h; simplify; reflexivity;}
end;

opaque symbol expnSr a n : Ï€ (a ^ s n = a ^ n Ã— a) â‰”
begin
  assume a n; rewrite expnS a n; rewrite mulnC; reflexivity;
end;

opaque symbol exp0n n : Ï€ (istrue (0 < n)) â†’ Ï€ (0 ^ n = 0) â‰”
begin
  induction
  { simplify; assume h; refine âŠ¥â‚‘ _ h;}
  { assume n h i; reflexivity; }
end;

opaque symbol exp1n n : Ï€ (1 ^ n = 1) â‰”
begin
  induction
  { reflexivity; }
  { assume n h; simplify; rewrite h; reflexivity; }
end;

opaque symbol expnD a m n: Ï€ (a ^ (m + n) = a ^ m Ã— a ^ n) â‰”
begin
  assume a;
  induction
  { reflexivity; }
  { assume m h n; simplify; rewrite h n; reflexivity; }
end;

opaque symbol expnMn m1 m2 n : Ï€ ((m1 Ã— m2) ^ n = m1 ^ n Ã— m2 ^ n) â‰”
begin
  assume m1 m2;
  induction
  { reflexivity; }
  { assume n h;  simplify; rewrite h; rewrite left mulnA (m1 ^ n) m2; rewrite mulnC (m1 ^ n) m2; rewrite mulnA m2 (m1 ^ n); reflexivity; }
end;

opaque symbol expnM m n1 n2 : Ï€ (m ^ (n1 Ã— n2) = (m ^ n1) ^ n2) â‰”
begin
  assume m;
  induction
  { assume n2; simplify; rewrite exp1n; reflexivity; }
  { assume n1 h n2; simplify; rewrite expnD; rewrite h n2; rewrite left expnMn; reflexivity; }
end;

opaque symbol expnAC m n1 n2 : Ï€ ((m ^ n1) ^ n2 = (m ^ n2) ^ n1) â‰”
begin
  assume m n1 n2; rewrite left expnM; rewrite mulnC; rewrite expnM; reflexivity; 
end;

opaque symbol expn_gt0 m n : Ï€ ((istrue (0 < m ^ n)) â‡” istrue (0 < m) âˆ¨ (n = 0)) â‰”
begin
  assume m n;
  apply âˆ§áµ¢ {
    generalize n;
    induction
    { simplify; assume h; apply âˆ¨áµ¢â‚‚ _ _ (eq_refl 0); }
    { assume n h i; 
      have t: Ï€ (istrue (0 < m ^ n)) { };
    }
  } {

  }; 
abort;

opaque symbol ltn_expl m n : Ï€ (istrue (1 < m)) â†’ Ï€ (istrue (n < m ^ n)) â‰”
begin
  assume m;
  induction
  { assume h; simplify; apply top; }
  { assume n h i; 
    have t: Ï€ (istrue (n < (m ^ n))) { apply h i; };
    rewrite expnS; 
  }
abort;

/************************************
************* Factorial *************
*************************************/

symbol ! : â„• â†’ â„•; 

notation ! postfix 40;

rule 0 ! â†ª 1
with (s $n) ! â†ª (s $n) Ã— $n !;

compute 8 !;

opaque symbol fact0 : Ï€ (0 ! = 1) â‰”
begin
  reflexivity;
end;

opaque symbol factS n : Ï€ ((s n) ! = (s n) Ã— n !) â‰”
begin
  reflexivity; 
end;

opaque symbol fact_gt0 n : Ï€ (istrue (n ! > 0)) â‰”
begin
  induction
  { apply top; }
  { assume n h; rewrite factS n; rewrite mulSnr n (n !); apply ltn_addl 0 (n !) (n Ã— n !); apply h; }
end;

opaque symbol fact_gt1 n : Ï€ (istrue (n ! â‰¥ 1)) â‰”
begin
  refine fact_gt0;
end;

opaque symbol fact_geq n : Ï€ (istrue (n â‰¤ n !)) â‰”
begin
  induction
  { apply top; }
  { assume n h; rewrite factS n; apply leq_pmulr (s n) (n !) (fact_gt0 n); }
end;
