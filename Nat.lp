/* Library on natural numbers

following https://github.com/math-comp/math-comp/blob/master/mathcomp/ssreflect/ssrnat.v

(lemmas with unfinished proofs:
ltn_neqAle, leq_eqVlt, gtn_max, geq_max, minnE, expn_gt0, ltn_expl). */

require open Blanqui.Lib.Set Blanqui.Lib.Prop Blanqui.Lib.FOL Blanqui.Lib.Eq
  Blanqui.Lib.Bool;

inductive â„• : TYPE â‰”
| zero : â„•
| s : â„• â†’ â„•;

// enable decimal notation

builtin "0"  â‰” zero;
builtin "+1" â‰” s;

assert âŠ¢ 42 : â„•;

// set code for â„•

constant symbol nat : Set;

rule Ï„ nat â†ª â„•;

symbol is0 : â„• â†’ ğ”¹;

// non confusion of constructors

rule is0 0 â†ª true
with is0 (s _) â†ª false;

opaque symbol sâ‰ 0 [n] : Ï€ (s n â‰  0) â‰”
begin
  assume n h; refine ind_eq h (Î» n, istrue(is0 n)) top
end;

opaque symbol 0â‰ s [n] : Ï€ (0 â‰  s n) â‰”
begin
  assume n h; apply @sâ‰ 0 n; symmetry; apply h
end;

// boolean equality on â„•

symbol =â„• : â„• â†’ â„• â†’ ğ”¹; notation =â„• infix 10;

rule 0 =â„• 0 â†ª true
with s $x =â„• s $y â†ª $x =â„• $y
with 0 =â„• s _ â†ª false
with s _ =â„• 0 â†ª false;

opaque symbol =â„•_correct x y : Ï€(istrue(x =â„• y)) â†’ Ï€(x = y) â‰”
begin
  induction
  { induction { reflexivity; } { assume x h i; apply âŠ¥â‚‘ i; } }
  { assume x h; induction
    { assume i; apply âŠ¥â‚‘ i; }
    { assume y i j; apply feq s; apply h _ j; }
  }
end;

opaque symbol =â„•_complete x y : Ï€(x = y) â†’ Ï€(istrue(x =â„• y)) â‰”
begin
  induction
  { assume y i; rewrite left i; apply top; }
  { simplify; assume x h; /*FIXME: x0 is replaced by x!*/ induction
    { assume i; apply sâ‰ 0 i; }
    { assume y i j; simplify; }
  }
abort;

// predecessor

symbol p : â„• â†’ â„•;

rule p 0 â†ª 0
with p (s $x) â†ª $x;

opaque symbol s_inj [x y] : Ï€ (s x = s y) â†’ Ï€ (x = y) â‰”
begin
  assume x y h; apply feq p h
end;

// addition

symbol + : â„• â†’ â„• â†’ â„•; notation + infix left 20;

assert x y z âŠ¢ x + y + z â‰¡ (x + y) + z;

rule 0 + $y â†ª $y
with s $x + $y â†ª s ($x + $y);

opaque symbol add0n x : Ï€ (0 + x = x) â‰”
begin
  assume x; reflexivity;
end;

opaque symbol addn0 x : Ï€ (x + 0 = x) â‰”
begin
  induction
  { reflexivity }
  { assume x' h; simplify; rewrite h; reflexivity }
end;

rule $x + 0 â†ª $x;

opaque symbol addSn x y : Ï€ (s x + y = s (x + y)) â‰”
begin
  assume x; reflexivity;
end;

opaque symbol addnS x y : Ï€ (x + s y = s (x + y)) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y; simplify; rewrite h; reflexivity }
end;

rule $x + s $y â†ª s ($x + $y);

opaque symbol add1n n : Ï€ (1 + n = s n) â‰”
begin
  assume n; reflexivity;
end;

opaque symbol addn1 n : Ï€ (n + 1 = s n) â‰”
begin
  assume n; reflexivity;
end;

opaque symbol addSnnS m n : Ï€ (s m + n = m + s n) â‰”
begin
  assume m n; reflexivity;
end;

opaque symbol addnC x y : Ï€ (x + y = y + x) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y; simplify; rewrite h; reflexivity }
end;

opaque symbol addnA x y z : Ï€ ((x + y) + z = x + (y + z)) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y z; simplify; rewrite h; reflexivity }
end;

rule ($x + $y) + $z â†ª $x + ($y + $z);

opaque symbol addnCA m n p : Ï€ ((m + n) + p = (m + p) + n) â‰”
begin
  assume m n p; symmetry; rewrite addnA; rewrite .[p + n] addnC;
  rewrite left addnA; reflexivity;
end;

opaque symbol addnAC m n p : Ï€ (m + (n + p) = n + (m + p)) â‰”
begin
  assume m n p; symmetry; rewrite left addnA; rewrite .[n + m] addnC;
  rewrite addnA; reflexivity; 
end;

opaque symbol addnCAC m n p : Ï€ (m + n + p = p + n + m) â‰”
begin
  assume m n p; rewrite addnC; rewrite .[m + _] addnC; rewrite addnA;
  reflexivity; 
end;

opaque symbol addnACl m n p : Ï€ (m + n + p = n + (p + m)) â‰”
begin
  assume m n p; rewrite .[m + _] addnC; rewrite addnA; rewrite .[m + _] addnC;
  reflexivity;
end;

opaque symbol addnACA m n p q : Ï€ ((m + n) + (p + q) = (m + p) + (n + q)) â‰”
begin
  assume m n p q; simplify; rewrite left .[p + (n + q)] addnA;
  rewrite .[p + n] addnC; rewrite .[(n + p) + q] addnA; reflexivity; 
end;

opaque symbol addnI x y z : Ï€ (z + x = z + y) â†’ Ï€ (x = y) â‰”
begin
  assume x y; induction
  { assume h; apply h;}
  { assume z h i; apply h; apply s_inj; apply i;}
end;

opaque symbol addIn x y z : Ï€ (x + z = y + z) â†’ Ï€ (x = y) â‰”
begin
  assume x y; induction
  { assume h; apply h;}
  { assume z h i; apply h; apply s_inj; apply i;}
end;

opaque symbol addn_eq0 m n : Ï€ (m + n = 0 â‡” m = 0 âˆ§ n = 0) â‰”
begin
  assume m n; apply âˆ§áµ¢ {
    generalize m; induction
    { assume m h; apply âˆ§áµ¢ (eq_refl 0) h; }
    { assume m h n i; apply âŠ¥â‚‘ (sâ‰ 0 i) }
  } {
    generalize m; induction
    { assume n h; apply âˆ§â‚‘â‚‚ h }
    { assume m h n i; apply âŠ¥â‚‘ (sâ‰ 0 (âˆ§â‚‘â‚ i)) }
  }
end;

opaque symbol eqn_add2l p m n : Ï€ ((p + m = p + n) â‡” (m = n)) â‰”
begin
  assume p m n;
  apply âˆ§áµ¢ {
    refine addnI m n p
  } {
    //FIXME: generalize p fails
    generalize m; generalize p; induction
    { assume m n h; apply h }
    { assume z h m n i; simplify; rewrite h m n i; reflexivity }  
  };
end;

opaque symbol eqn_add2r p m n : Ï€ ((m + p = n + p) â‡” (m = n)) â‰”
begin
  assume p m n; rewrite addnC m p; rewrite addnC n p; apply eqn_add2l p m n;
end;

// substraction

symbol - : â„• â†’ â„• â†’ â„•; notation - infix left 20;

rule 0 - _ â†ª 0
with $x - 0 â†ª $x
with (s $x) - (s $y) â†ª $x - $y;

opaque symbol sub0n n : Ï€ (n - 0 = n) â‰”
begin
  reflexivity;
end;

opaque symbol subn0 n : Ï€ (0 - n = 0) â‰”
begin
  reflexivity;
end;

opaque symbol subnn x : Ï€ (x - x = 0) â‰”
begin
  induction
  { reflexivity }
  { assume x h; simplify; apply h;}
end;

rule $x - $x â†ª 0;

opaque symbol subSS m n : Ï€ (s m - s n = m - n) â‰”
begin
  reflexivity;
end;

opaque symbol subn1 n : Ï€ (n - 1 = p n) â‰”
begin
  induction
  { reflexivity; }
  { assume n h; reflexivity;  }
end;

opaque symbol subnS x y : Ï€ (x - s y = p (x - y)) â‰”
begin
  induction
  { reflexivity; }
  { assume x h; induction
    { reflexivity; }
    { assume y i; simplify; rewrite h; reflexivity }
  }
end;

opaque symbol subSnn n : Ï€ (s n - n = 1) â‰”
begin
  induction
  { reflexivity; }
  { assume n h; simplify; apply h; }
end;

opaque symbol predn_sub x y : Ï€ (p (x - y) = p x - y) â‰”
begin
  induction
  { reflexivity; }
  { assume x h; induction
    { reflexivity; }
    { assume y i; simplify; symmetry; rewrite subnS; reflexivity; }
  }
end;

opaque symbol subnAC z x y : Ï€ ((x - y) - z = (x - z) - y) â‰”
begin
  induction
  { reflexivity; }
  { assume z h; induction
    { reflexivity; }   
    { assume x i; induction
      { reflexivity; }
      { assume y j; simplify; rewrite i; rewrite subnS; symmetry;
        rewrite subnS; rewrite predn_sub; reflexivity}
    }
  }
end;

opaque symbol addnK x y : Ï€ (x + y - y = x) â‰”
begin
  induction
  { reflexivity; }
  { assume x h; induction
    { reflexivity; }
    { simplify; assume y i; rewrite i; reflexivity; }
  }
end;

opaque symbol subnDA x y z : Ï€ (x - (y + z) = (x - y) - z) â‰”
begin
  induction
  { reflexivity }
  { assume x h; induction
    { reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; simplify; rewrite subnS; symmetry; rewrite subnS;
        rewrite h; reflexivity; }
    }
  }
end;

opaque symbol subnDl z x y : Ï€ ((z + x) - (z + y) = x - y) â‰”
begin
  induction
  { reflexivity }
  { assume z h; induction
    { assume y; simplify; rewrite subnDA; reflexivity; }
    { assume x i; induction
      { rewrite addnC; rewrite addn0; rewrite addnK; reflexivity; }
      { assume y j; rewrite addnC; rewrite subnDA; rewrite addnK; reflexivity }
    }
  }
end;

opaque symbol subnDr z x y : Ï€ ((x + z) - (y + z) = x - y) â‰”
begin
  assume z x y; rewrite addnC; rewrite .[y + _] addnC; rewrite subnDl;
  reflexivity;
end;

opaque symbol subSKn m n : Ï€ (p (s m - n) = m - n) â‰”
begin
  assume m n; rewrite left subnS; reflexivity;
end;

// multiplication

symbol * : â„• â†’ â„• â†’ â„•; notation * infix left 30; // \times

assert x y z âŠ¢ x + y * z â‰¡ x + (y * z);

rule 0 * _  â†ª 0
with s $x * $y â†ª $y + $x * $y;

opaque symbol mul0n x : Ï€ (x * 0 = 0) â‰”
begin
  induction { reflexivity } { assume x' h; apply h }
end;

rule _ * 0 â†ª 0;

opaque symbol muln0 x : Ï€ (0 * x = 0) â‰”
begin
  assume x; reflexivity;
end;

opaque symbol mul1n n : Ï€ (1 * n = n) â‰”
begin
  assume n; reflexivity;
end;

opaque symbol muln1 n : Ï€ (n * 1 = n) â‰”
begin
  induction
  { reflexivity; }
  { assume n h; simplify; rewrite h; reflexivity; }
end;

opaque symbol mulSn m n : Ï€ (s m * n = n + m * n) â‰”
begin
  reflexivity;
end;

opaque symbol mulSnr m n : Ï€ (s m * n = m * n + n) â‰”
begin
  assume m n; rewrite addnC; reflexivity;
end;

opaque symbol mulnS x y : Ï€ (x * s y = x + x * y) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y; simplify; rewrite h; rewrite addnAC; reflexivity }
end;

//rule $x * s $y â†ª $x + $x * $y; is confluent modulo C only

opaque symbol mulnSr x y : Ï€ (x * s y = x * y + x) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y; simplify; rewrite mulnS; rewrite .[x' + _] addnC;
    reflexivity }
end;

//rule $x * s $y â†ª $x * $y + $x; is confluent modulo C only

opaque symbol mulnC x y : Ï€ (x * y = y * x) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y; simplify; rewrite mulnS; rewrite h; reflexivity }
end;

opaque symbol mulnDl x y z : Ï€ ((x + y) * z = x * z + y * z) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y z; simplify; rewrite h; reflexivity }
end;

//rule ($x + $y) * $z â†ª $x * $z + $y * $z; is confluent modulo AC only

opaque symbol mulnDr x y z : Ï€ (z * (x + y) = z * x + z * y) â‰”
begin
  assume x y z; rewrite mulnC; rewrite mulnDl; rewrite mulnC;
  rewrite .[y * _] mulnC; reflexivity
end;

//rule $z * ($x + $y) â†ª $z * $x + $z * $y; is confluent modulo AC only

opaque symbol mulnBr x y z : Ï€ (x * (y - z) = x * y - x * z) â‰”
begin
  induction
  { reflexivity; }
  { assume x h; induction
    { reflexivity; }
    { assume y i; induction
      { reflexivity; }
      { assume z j; simplify; rewrite mulnS; rewrite mulnS;
        rewrite left addnAC; rewrite .[z + (x + _)] addnAC; 
        rewrite subnDl; rewrite left mulSn; rewrite left mulSn;
        rewrite left mulSn; rewrite left i; reflexivity; }
    }
  }
end;

opaque symbol mulnBl x y z : Ï€ ((x - y) * z = x * z - y * z) â‰”
begin
  assume x y z; rewrite mulnC; rewrite .[x * z] mulnC; rewrite .[y * z] mulnC;
  rewrite left mulnBr; reflexivity;
end;

opaque symbol mulnA x y z : Ï€ ((x * y) * z = x * (y * z)) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y z; simplify; rewrite mulnDl; rewrite h; reflexivity }
end;

//rule ($x * $y) * $z â†ª $x * ($y * $z); is not confluent

opaque symbol mulnCA x y z: Ï€ (x * (y * z) = y * (x * z)) â‰”
begin
  assume x y z; rewrite left mulnA; rewrite .[x * y] mulnC; rewrite mulnA;
  reflexivity;
end;

opaque symbol mulnAC x y z: Ï€ ((x * y) * z = (x * z) * y) â‰”
begin
  assume x y z; rewrite mulnA; rewrite .[y * z] mulnC; rewrite left mulnA;
  reflexivity;
end;

opaque symbol mulnACA x y z t: Ï€ ((x * y) * (z * t) = (x * z) * (y * t)) â‰”
begin
  assume x y z t; rewrite mulnA; rewrite .[y * _] mulnCA; rewrite mulnA;
  reflexivity;
end;

opaque symbol muln_eq0 m n : Ï€ (m * n = 0 â‡” m = 0 âˆ¨ n = 0) â‰”
begin
  assume m n; apply âˆ§áµ¢ {
    generalize m; induction
    { assume n h; apply âˆ¨áµ¢â‚ h; }
    { assume m h n i; 
      have t: Ï€ (n = 0 âˆ§ (m * n) = 0) { apply âˆ§â‚‘â‚ (addn_eq0 n (m * n)) i; }; 
      have u: Ï€ (n = 0) { apply âˆ§â‚‘â‚ t; };
      apply âˆ¨áµ¢â‚‚ u;
    }
  } {
    assume h;
    refine âˆ¨â‚‘ h _ _ {
      assume i; rewrite i; reflexivity;
    } {
      assume i; rewrite i; reflexivity;
    };
  };
end;

// order on â„•

symbol â‰¤ : â„• â†’ â„• â†’ ğ”¹; notation â‰¤ infix left 10;

rule 0 â‰¤ _ â†ª true
with s _ â‰¤ 0 â†ª false
with s $x â‰¤ s $y â†ª $x â‰¤ $y;

symbol < : â„• â†’ â„• â†’ ğ”¹; notation < infix 10;

rule $x < $y â†ª s $x â‰¤ $y;

symbol â‰¥ : â„• â†’ â„• â†’ ğ”¹; notation â‰¥ infix 10;

rule $x â‰¥ $y â†ª $y â‰¤ $x;

symbol > : â„• â†’ â„• â†’ ğ”¹; notation > infix 10;

rule $x > $y â†ª s $y â‰¤ $x;

opaque symbol â‰¤0 x : Ï€ (istrue (x â‰¤ 0)) â†’ Ï€ (x = 0) â‰”
begin
  induction
  { assume h; reflexivity;}
  { assume x h i; apply âŠ¥â‚‘; apply i; }
end;

opaque symbol â‰¤_refl x : Ï€ (istrue (x â‰¤ x)) â‰”
begin
  induction
  { simplify; apply top;}
  { assume x h; simplify; apply h; }
end;

opaque symbol eq_leq x y : Ï€ (x = y) â†’ Ï€ (istrue (x â‰¤ y)) â‰”
begin 
  assume x y h; rewrite h; apply â‰¤_refl y;
end;

opaque symbol leq_trans [x y z] : Ï€ (istrue (x â‰¤ y)) â†’ Ï€ (istrue (y â‰¤ z)) â†’ Ï€ (istrue (x â‰¤ z)) â‰”
begin
  induction
  { assume y z h i; apply h; }
  { assume x h; induction
    { assume y i; apply âŠ¥â‚‘ i; }
    { assume y i; induction
      { assume j k; apply k; }
      { assume z j k l; apply h y z k l; }
    }
  }
end;

opaque symbol eqn_leq x y : Ï€ (istrue (x â‰¤ y) âˆ§ istrue (y â‰¤ x) â‡” (x = y)) â‰”
begin
  assume x y; apply âˆ§áµ¢ {
    generalize x; induction
    { assume y g; 
      have i: Ï€ (istrue (y â‰¤ 0)) { apply âˆ§â‚‘â‚‚ g; };
      symmetry; apply â‰¤0 y i;
    }
    {
      assume x h; induction
      { assume g; 
        have i: Ï€ (istrue (s x â‰¤ 0)) { apply âˆ§â‚‘â‚ g; };
        apply â‰¤0 (s x) i;
      }
      { assume y i j; apply feq s; apply h y j;}
    }
  } {
    assume h;
    have t: Ï€ (istrue (x â‰¤ y)) { apply eq_leq _ _ h;};
    have u: Ï€ (istrue (y â‰¤ x)) { apply eq_leq y x _; symmetry; apply h;};
    apply âˆ§áµ¢ t u;
  };
end;

opaque symbol leqsnn n: Ï€ (istrue (s n â‰¤ n)) â†’ Ï€ âŠ¥ â‰”
begin
  induction
  { assume h; apply h; }
  { assume n h i; apply h; apply i;}
end;

opaque symbol letnS m n : Ï€ (istrue (m < s n)) â†’ Ï€ (istrue (m â‰¤ n)) â‰”
begin
  assume m n h; apply h;
end;

opaque symbol ltn0 n : Ï€ (istrue (n < 0)) â†’ Ï€ âŠ¥ â‰”
begin
  assume n h; apply h;
end;

opaque symbol ltnn n : Ï€ (istrue (n < n)) â†’ Ï€ âŠ¥ â‰”
begin
  assume n h; apply leqsnn n; apply h;
end;

opaque symbol ltnSn n : Ï€ (istrue (n < s n)) â‰”
begin
  assume n; simplify; apply â‰¤_refl n;
end;

opaque symbol leq0n n : Ï€ (istrue (0 â‰¤ n)) â‰”
begin
  induction
  { apply â‰¤_refl 0;}
  { assume n h; simplify; apply h; }
end;

opaque symbol ltn0Sn n : Ï€ (istrue (0 < s n)) â‰”
begin
  assume n; apply leq0n n;
end;

opaque symbol leqnSn n : Ï€ (istrue (n â‰¤ s n)) â‰”
begin
  induction
  { apply leq0n 1; }
  { assume n h; simplify; apply h; }
end;

opaque symbol leq_pred n : Ï€ (istrue (p n â‰¤ n)) â‰”
begin
  induction
  { apply top;}
  { assume n h; simplify; apply leqnSn n;} 
end;

opaque symbol ltnW m n : Ï€ (istrue (m < n)) â†’ Ï€ (istrue (m â‰¤ n)) â‰”
begin
  induction
  { assume m h; apply top;}
  { assume m h; induction
    { assume i; apply i;}
    { assume n i j; apply h n; apply j;}
  }
end;

opaque symbol leqW m n : Ï€ (istrue (m â‰¤ n)) â†’ Ï€ (istrue (m â‰¤ s n)) â‰”
begin
  assume m n h; apply ltnW m (s n); simplify; apply h;
end;

opaque symbol ltn_trans x y z : Ï€ (istrue (x < y)) â†’ Ï€ (istrue (y < z)) â†’ Ï€ (istrue (x < z)) â‰”
begin
  assume x y z h i;
  have v:Ï€ (istrue (s x â‰¤ s y)) { apply leqW (s x) y h; };
  apply @leq_trans (s x) (s y) z v i; //FIXME
end;

opaque symbol <_asym x y : Ï€ (istrue (x < y)) â†’ Ï€ (Â¬ (istrue (y < x))) â‰”
begin
  assume x y h i;
  have t:Ï€ (istrue (y â‰¤ s y)) { apply leqnSn y; };
  have u:Ï€ (istrue (s x â‰¤ s y)) { apply @leq_trans (s x) y (s y) h t; }; 
  have v:Ï€ (istrue (s x â‰¤ x)) { apply @leq_trans (s x) (s y) x u i; };
  apply leqsnn x; apply v;
end;

opaque symbol anti_ltn x y : Ï€(istrue (x < y)) â†’ Ï€(istrue (y < x)) â†’ Ï€(x = y) â‰”
begin
  assume x y h i;
  have c:Ï€ (istrue (x â‰¤ s x)) { apply leqnSn x; };
  have d:Ï€ (istrue (y â‰¤ s y)) { apply leqnSn y; };
  have e:Ï€ (istrue (x â‰¤ y)) { apply @leq_trans x (s x) y c h; };
  have f:Ï€ (istrue (y â‰¤ x)) { apply @leq_trans y (s y) x d i; };
  have g:Ï€ (istrue (x â‰¤ y) âˆ§ istrue (y â‰¤ x)) { apply âˆ§áµ¢ e f; }; 
  apply âˆ§â‚‘â‚ (eqn_leq x y) g;
end;

opaque symbol leq_total x y : Ï€ (istrue (x â‰¤ y) âˆ¨ istrue (y â‰¤ x)) â‰”
begin
  induction
  { assume y; simplify; apply âˆ¨áµ¢â‚; apply top; }
  { assume x h; induction
    { simplify; apply âˆ¨áµ¢â‚‚; apply top; }
    { assume y i; simplify; apply h y; }
  }
end;

opaque symbol lt0n n : Ï€ (istrue (n > 0) â‡” (n â‰  0)) â‰”
begin
  assume n; apply âˆ§áµ¢ {
    generalize n; induction
    { assume h i; apply h; }
    { assume n h i j; apply sâ‰ 0 j;}
  } {
    generalize n; induction
    { assume h; apply h (eq_refl 0); }
    { assume n h i; apply top; }
  };
end;

opaque symbol leq_eqVlt m n : Ï€ (istrue (m â‰¤ n) â‡” (m = n) âˆ¨ istrue (m < n)) â‰”
begin
  assume m n; apply âˆ§áµ¢ {
    generalize m; induction
    { induction
      { assume h; apply âˆ¨áµ¢â‚ (eq_refl 0) }
      { assume n h i; apply âˆ¨áµ¢â‚‚ top }
    }
    { assume m h; induction
      { assume i; apply âˆ¨áµ¢â‚‚ i }
      { assume n i j; apply âˆ¨â‚‘ (h n j)
        { assume e; apply âˆ¨áµ¢â‚; rewrite e; reflexivity }
        { assume e; apply âˆ¨áµ¢â‚‚; apply e }
      }
    }
  } {
    assume h; apply âˆ¨â‚‘ h {
      assume i; apply eq_leq m n i 
    } {
      assume i; apply ltnW m n i
    }
  }
end;

opaque symbol ltn_neqAle m n : Ï€ (istrue (m < n) â‡” istrue (m â‰¤ n) âˆ§ (m â‰  n)) â‰”
begin
abort;

opaque symbol leq_add0 m n :
  Ï€ (istrue (0 â‰¤ m)) â†’ Ï€ (istrue (0 â‰¤ n)) â†’ Ï€ (istrue (0 â‰¤ m + n)) â‰”
begin
  assume m n h i; apply leq0n (m + n);
end;

opaque symbol leq_add2l p m n : Ï€ (istrue (p + m â‰¤ p + n) â‡” istrue (m â‰¤ n)) â‰”
begin
  assume p m n; apply âˆ§áµ¢ {
    //FIXME: generalize p fails
    generalize m; generalize p; induction
    { assume m n h; apply h; }
    { assume p h m n i; apply h m n i; }
  } {
    generalize m; generalize p; induction
    { assume m n h; apply h; }
    { assume p h m n i; apply h m n i; }
  }; 
end;

opaque symbol ltn_add2l p m n : Ï€ (istrue (p + m < p + n) â‡” istrue (m < n)) â‰”
begin
  assume p m n; simplify; rewrite left addnS; refine leq_add2l p (s m) n;
end;

opaque symbol leq_add2r p m n : Ï€ (istrue (m + p â‰¤ n + p) â‡” istrue (m â‰¤ n)) â‰”
begin
  assume p m n; rewrite addnC m p; rewrite addnC n p; refine leq_add2l p m n; 
end;

opaque symbol ltn_add2r p m n : Ï€ (istrue (m + p < n + p) â‡” istrue (m < n)) â‰”
begin
  assume p m n; rewrite addnC m p; rewrite addnC n p; refine ltn_add2l p m n; 
end;

opaque symbol leq_addl m n : Ï€ (istrue (n â‰¤ m + n)) â‰”
begin
  assume m; induction
  { apply top; }
  { assume n h; apply h; }
end;

opaque symbol leq_addr m n : Ï€ (istrue (n â‰¤ n + m)) â‰”
begin
  assume m n; rewrite addnC n m; apply leq_addl m n;
end;

opaque symbol leq_subr m n : Ï€ (istrue (n - m â‰¤ n)) â‰”
begin
  induction
  { assume n; apply â‰¤_refl n; }
  { assume m h; induction
    { apply top; }
    { assume n i; simplify; 
      have t: Ï€ (istrue (n â‰¤ s n)) { apply leqnSn n };
      apply @leq_trans (n - m) n (s n) (h n) t;
    }
  }
end;

opaque symbol subn_eq0 m n : Ï€ ((m - n = 0) â‡” istrue (m â‰¤ n)) â‰”
begin
  assume m n; apply âˆ§áµ¢ {
    generalize m; induction
    { assume n h; apply top; }
    { assume m h; induction
      { assume i; apply sâ‰ 0 i; }
      { assume n i j; apply h n j; }
    }
  } {
    generalize m; induction
    { assume n h; apply eq_refl 0; }
    { assume m h; induction
      { assume i; apply âŠ¥â‚‘ i; }
      { assume n i j; apply h n j; }
    }
  };
end;

opaque symbol ltn_addl m n p : Ï€ (istrue (m < n)) â†’ Ï€ (istrue (m < p + n)) â‰”
begin
  assume m n; induction
  { assume h; apply h; }
  { assume p h i; refine @leq_trans m (s m) (p + n) (leqnSn m) (h i); }
end;

opaque symbol ltn_addr m n p : Ï€ (istrue (m < n)) â†’ Ï€ (istrue (m < n + p)) â‰”
begin
  assume m n p h; rewrite addnC n p; apply ltn_addl m n p; apply h;
end; 

opaque symbol addn_gt0 m n :
  Ï€ (istrue (0 < m + n) â‡” istrue (0 < m) âˆ¨ istrue (0 < n)) â‰”
begin
  assume m n; apply âˆ§áµ¢ {
    generalize m; induction
    { assume n i; apply âˆ¨áµ¢â‚‚ i; }
    { assume m h n i; apply âˆ¨áµ¢â‚; apply ltn0Sn m; }
  } {
    assume h; apply âˆ¨â‚‘ h {
      assume i; apply ltn_addr 0 m n i;
    } {
      assume i; apply ltn_addl 0 n m i;
    };
  };
end;

opaque symbol subn_gt0 m n : Ï€ (istrue (0 < n - m) â‡” istrue (m < n)) â‰”
begin
  assume m n; apply âˆ§áµ¢ {
    generalize m; induction
    { assume n h; apply h; }
    { assume m h; induction
      { assume i; apply i; }
      { assume n i; rewrite subSS; assume j; 
        have t: Ï€ (istrue (m < n)) { apply h n j; };
        have u: Ï€ (istrue (m + 1 < n + 1)) { refine âˆ§â‚‘â‚‚ (ltn_add2r 1 m n) t; };
        rewrite left addn1 m; rewrite left addn1 n; apply u;
      }
    }
  } {
    generalize m; induction
    { assume n h; apply h; }
    { assume m h; induction
      { assume i; apply i; }
      { assume n i j; rewrite subSS; apply h n;
        refine âˆ§â‚‘â‚ (ltn_add2r 1 m n) j;
      }
    }
  };
end;

opaque symbol leq_add m1 m2 n1 n2 :
  Ï€ (istrue (m1 â‰¤ n1)) â†’ Ï€ (istrue (m2 â‰¤ n2)) â†’ Ï€ (istrue (m1 + m2 â‰¤ n1 + n2)) â‰”
begin
  assume m1 m2 n1 n2 h i;
  have a: Ï€ (istrue (m1 + m2 â‰¤ m1 + n2)) { apply âˆ§â‚‘â‚‚ (leq_add2l m1 m2 n2) i; };
  have b: Ï€ (istrue (m1 + n2 â‰¤ n1 + n2)) { refine âˆ§â‚‘â‚‚ (leq_add2r n2 m1 n1) h; };
  refine @leq_trans (m1 + m2) (m1 + n2) (n1 + n2) a b;
end;

opaque symbol leq_subLR m n p : Ï€ (istrue (m - n â‰¤ p) â‡” istrue (m â‰¤ n + p)) â‰”
begin
  assume m n p; apply âˆ§áµ¢
  { assume h;
    have t: Ï€ (((m - (n + p)) = 0)) â†’ Ï€ (istrue (m â‰¤ (n + p)))
      { apply âˆ§â‚‘â‚ (subn_eq0 m (n + p)); };
    apply t; rewrite subnDA; apply âˆ§â‚‘â‚‚ (subn_eq0 (m - n) p) h;
  }
  { assume h; 
    have t: Ï€ (((m - n) - p) = 0) â†’ Ï€ (istrue ((m - n) â‰¤ p))
      { apply âˆ§â‚‘â‚ (subn_eq0 (m - n) p); };
    apply t; rewrite left subnDA; apply âˆ§â‚‘â‚‚ (subn_eq0 m (n + p)) h;
  };
end;

opaque symbol subnKC m n : Ï€ (istrue (m â‰¤ n)) â†’ Ï€ (m + (n - m) = n) â‰”
begin
  induction
  { assume n h; apply eq_refl n; }
  { assume m h; induction
    { assume i; apply âŠ¥â‚‘ i; }
    { assume n i j; apply feq s; apply h; apply j; }
  }
end;

opaque symbol addnBn m n : Ï€ (m + (n - m) = m - n + n) â‰”
begin
  induction
  { assume n; apply eq_refl n; }
  { assume m h; induction
    { apply eq_refl (s m); }
    { assume n i; simplify; apply feq s; apply h n; }
  }
end;

opaque symbol subnK m n : Ï€ (istrue (m â‰¤ n)) â†’ Ï€ ((n - m) + m = n) â‰”
begin
  assume m n h; rewrite addnC; apply subnKC m n h;
end;

opaque symbol subSn n p : Ï€ (istrue (p â‰¤ n)) â†’ Ï€ (s n - p = s (n - p)) â‰”
begin
  induction
  { assume p h; simplify;
    have t: Ï€ (p = 0) { apply â‰¤0 p h; };
    rewrite t; reflexivity;
  } {
    assume n h; induction
    { assume i; reflexivity; }
    { assume p i j; apply h p j }
  }
end;

opaque symbol addnBA m n p : Ï€ (istrue (p â‰¤ n))  â†’ Ï€ (m + (n - p) = m + n - p) â‰”
begin
  induction
  { assume n p h; reflexivity; }
  { assume m h n p i; simplify; rewrite left addnS m (n - p);
    rewrite left addnS m n; rewrite left h (s n) p (leqW p n i);
    rewrite subSn n p i; reflexivity; 
  }
end;

opaque symbol addnBAC m n p : Ï€ (istrue (n â‰¤ m)) â†’ Ï€ (m - n + p = m + p - n) â‰”
begin
  assume m n p h;
  rewrite addnC; rewrite addnBA p m n h; rewrite addnC; reflexivity;
end;

opaque symbol leq_sub2r m n p : Ï€ (istrue (m â‰¤ n)) â†’ Ï€ (istrue (m - p â‰¤ n - p)) â‰”
begin
  assume m n p h; apply âˆ§â‚‘â‚‚ (leq_subLR m p (n - p)) _;
  apply âˆ¨â‚‘ (leq_total p n) {
    assume i; rewrite subnKC p n i; apply h;
  } {
    assume i;
    have t: Ï€(n - p = 0) { apply âˆ§â‚‘â‚‚ (subn_eq0 n p) i };
    rewrite t; simplify; apply @leq_trans m n p h i;
  };
end;

opaque symbol leq_sub2l m n p : Ï€ (istrue (m â‰¤ n)) â†’ Ï€ (istrue (p - n â‰¤ p - m)) â‰”
begin
  assume m n p h; apply âˆ§â‚‘â‚‚ (leq_subLR p n (p - m)) _;
  apply âˆ¨â‚‘ (leq_total p m) {
    assume i;
    have t:Ï€ (p - m = 0) { apply (âˆ§â‚‘â‚‚ (subn_eq0 p m) i) };
    rewrite t; simplify; apply @leq_trans p m n i h;
  } {
    assume i; apply âˆ§â‚‘â‚ (leq_add2r m p (n + (p - m))) _;
    rewrite addnA; rewrite subnK m p i; rewrite addnC n p;
    apply âˆ§â‚‘â‚‚ (leq_add2l p m n) h;
  };
end;

opaque symbol leq_sub m1 m2 n1 n2 :
  Ï€ (istrue (m1 â‰¤ m2)) â†’ Ï€ (istrue (n2 â‰¤ n1)) â†’ Ï€ (istrue (m1 - n1 â‰¤ m2 - n2)) â‰”
begin
  assume m1 m2 n1 n2 h i;
  have t:Ï€ (istrue (m1 - n1 â‰¤ m2 - n1)) { apply leq_sub2r m1 m2 n1 h; };
  have u:Ï€ (istrue (m2 - n1 â‰¤ m2 - n2)) { apply leq_sub2l n2 n1 m2 i; };
  apply @leq_trans (m1 - n1) (m2 - n1) (m2 - n2) t u;
end;

// max

symbol max: â„• â†’ â„• â†’ â„•;

rule max 0 $x â†ª $x
with max $x 0 â†ª $x
with max (s $x) (s $y) â†ª s (max $x $y);

opaque symbol maxnC x y : Ï€ (max x y = max y x) â‰”
begin
  induction
  { reflexivity }
  { assume x h; induction
    { reflexivity }
    { assume y i; simplify; rewrite h; reflexivity }
  }
end;

opaque symbol maxnA x y z : Ï€ (max (max x y) z = max x (max y z)) â‰”
begin
  induction
  { reflexivity }
  { assume x h; induction
    { reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; simplify; rewrite h; reflexivity }
    }
  }
end;

opaque symbol maxnAC x y z : Ï€ (max (max x y) z = max (max x z) y) â‰”
begin
  assume x y z; rewrite maxnA; rewrite maxnC y z; rewrite left maxnA;
  reflexivity;
end;

opaque symbol maxnCA x y z : Ï€ (max x (max y z) = max y (max x z)) â‰”
begin
  assume x y z; rewrite left maxnA; rewrite maxnC x y; rewrite maxnA;
  reflexivity; 
end;

opaque symbol maxnACA x y z t: Ï€ (max (max x y) (max z t) = max (max x z) (max y t)) â‰”
begin
  assume x y z t; rewrite maxnA; rewrite maxnC y (max z t); rewrite maxnA;
  rewrite left maxnA x z; rewrite maxnC t y; reflexivity;
end;

opaque symbol addn_maxl x y z: Ï€ ((max y z) + x = max (y + x) (z + x)) â‰”
begin
  induction
  { reflexivity; }
  { assume x h y z; simplify; apply feq s; rewrite h; reflexivity;}
end;

opaque symbol addn_maxr x y z : Ï€ (x + (max y z) = max (x + y) (x + z)) â‰”
begin
  induction
  { reflexivity }
  { assume x h y z; simplify; apply feq s; rewrite h; reflexivity }
end;

opaque symbol subn_maxl x y z: Ï€ ( (max x y) - z = max (x - z) (y - z) ) â‰”
begin
  induction
  { assume y z; reflexivity; }
  { assume x h; induction
    { assume z; reflexivity; }
    { assume y i; induction
      { reflexivity; }
      { assume z j; simplify; apply h y z; }
    }
  }
end;

opaque symbol maxnE m n : Ï€ (max m n = m + (n - m)) â‰”
begin
  induction
  { assume n; reflexivity; }
  { assume m h; induction
    { simplify;  reflexivity; }
    { assume n i; simplify; rewrite h; reflexivity; }
  }
end;

opaque symbol maxnn x : Ï€ (max x x = x) â‰”
begin
  induction
  { reflexivity; }
  { assume x h; simplify; rewrite h; reflexivity; }
end;

rule max $x $x â†ª $x;

opaque symbol leq_maxl m n : Ï€ (istrue (m â‰¤ max m n)) â‰”
begin
  induction
  { assume n; apply top; }
  { assume m h; induction
    { simplify; apply â‰¤_refl m; }
    { assume n i; simplify; apply h n; }
  }
end;

opaque symbol leq_maxr m n : Ï€ (istrue (n â‰¤ max m n)) â‰”
begin
  assume m n; rewrite maxnC m n; apply leq_maxl n m;
end;

opaque symbol gtn_max m n1 n2 :
  Ï€ (istrue (m > max n1 n2) â‡” istrue (m > n1) âˆ§ istrue (m > n2)) â‰”
begin
abort;

opaque symbol geq_max m n1 n2 :
  Ï€ (istrue (m â‰¥ max n1 n2) â‡” istrue (m â‰¥ n1) âˆ§ istrue (m â‰¥ n2)) â‰”
begin
abort;

opaque symbol ltn_predK m n : Ï€ (istrue (m < n)) â†’ Ï€ (s (p n) = n) â‰”
begin
  assume m; induction
  { assume h; refine âŠ¥â‚‘ h; }
  { assume n h i; reflexivity; }
end;

opaque symbol prednK n : Ï€ (istrue (0 < n)) â†’ Ï€ (s (p n) = n) â‰”
begin
  refine ltn_predK 0; 
end;

opaque symbol leq_pmull m n : Ï€ (istrue (n > 0)) â†’ Ï€ (istrue (m â‰¤ n * m)) â‰”
begin
  assume m n h; 
  have t: Ï€ (s (p n) = n) { apply prednK n h; };
  rewrite left t; simplify; apply leq_addr (p n * m) m; 
end;

opaque symbol leq_pmulr m n : Ï€ (istrue (n > 0)) â†’ Ï€ (istrue (m â‰¤ m * n)) â‰”
begin
  assume m n h; rewrite mulnC; apply leq_pmull m n h; 
end; 

opaque symbol leq_mul2l m n1 n2 :
  Ï€ (istrue (m * n1 â‰¤ m * n2) â‡” (m = 0) âˆ¨ istrue (n1 â‰¤ n2)) â‰”
begin
  assume m n1 n2;
  apply âˆ§áµ¢ { 
    assume h;
    have t:Ï€ (m * (n1 - n2) = 0) {
      rewrite mulnBr; apply âˆ§â‚‘â‚‚ (subn_eq0 (m * n1) (m * n2)) h;
    };
    have u: Ï€ (m = 0 âˆ¨ n1 - n2 = 0) { apply âˆ§â‚‘â‚ (muln_eq0 m (n1 - n2)) t; };
    apply âˆ¨â‚‘ u {
      assume i; refine âˆ¨áµ¢â‚ i; 
    } {
      assume i; apply âˆ¨áµ¢â‚‚; apply âˆ§â‚‘â‚ (subn_eq0 n1 n2) i; 
    }; 
  } { 
    assume h; apply âˆ§â‚‘â‚ (subn_eq0 (m * n1) (m * n2)) _; rewrite left mulnBr;
    apply âˆ¨â‚‘ h { 
      assume i; rewrite i; reflexivity; 
    } {
      assume i;
      have t:Ï€ (n1 - n2 = 0) { apply âˆ§â‚‘â‚‚ (subn_eq0 n1 n2) i; };
      rewrite t; reflexivity;
    };
  }
end;

opaque symbol leq_mul2r m n1 n2 :
  Ï€ (istrue (n1 * m â‰¤ n2 * m) â‡” (m = 0) âˆ¨ (istrue (n1 â‰¤ n2))) â‰”
begin
  assume m n1 n2; rewrite mulnC n1 m; rewrite mulnC n2 m;
  refine leq_mul2l m n1 n2; 
end;

opaque symbol leq_mul m1 m2 n1 n2 :
  Ï€ (istrue (m1 â‰¤ n1)) â†’ Ï€ (istrue (m2 â‰¤ n2)) â†’ Ï€ (istrue (m1 * m2 â‰¤ n1 * n2)) â‰”
begin
  assume m1 m2 n1 n2 h1 h2;
  have t1:Ï€ ((m2 = 0) âˆ¨ istrue (m1 â‰¤ n1)) { apply âˆ¨áµ¢â‚‚ h1; };
  have t2:Ï€ ((n1 = 0) âˆ¨ istrue (m2 â‰¤ n2)) { apply âˆ¨áµ¢â‚‚ h2; };
  have u1:Ï€ (istrue (m1 * m2 â‰¤ n1 * m2)) { apply âˆ§â‚‘â‚‚ (leq_mul2r m2 m1 n1) t1 };
  have u2:Ï€ (istrue (n1 * m2 â‰¤ n1 * n2)) { apply âˆ§â‚‘â‚‚ (leq_mul2l n1 m2 n2) t2 }; 
  apply @leq_trans (m1 * m2) (n1 * m2) (n1 * n2) u1 u2;
end;

opaque symbol eqn_mul2l m n1 n2 : Ï€ (m * n1 = m * n2 â‡” (m = 0) âˆ¨ (n1 = n2)) â‰”
begin
  assume m n1 n2;
  apply âˆ§áµ¢ {
    assume h;
    have t:Ï€ (istrue (m * n1 â‰¤ m * n2) âˆ§ istrue (m * n2 â‰¤ m * n1))
      { apply âˆ§â‚‘â‚‚ (eqn_leq (m * n1) (m * n2)) h; };
    have t1:Ï€ (istrue (m * n1 â‰¤ m * n2)) { apply âˆ§â‚‘â‚ t; };
    have t2:Ï€ (istrue (m * n2 â‰¤ m * n1)) { apply âˆ§â‚‘â‚‚  t; };
    have u1: Ï€ ((m = 0) âˆ¨ istrue (n1 â‰¤ n2)) { apply âˆ§â‚‘â‚(leq_mul2l m n1 n2) t1 };
    have u2: Ï€ ((m = 0) âˆ¨ istrue (n2 â‰¤ n1)) { apply âˆ§â‚‘â‚(leq_mul2l m n2 n1) t2 };
    apply âˆ¨â‚‘ u1 {
      assume i; apply âˆ¨áµ¢â‚ i;
    } {
      assume i; 
      apply âˆ¨â‚‘ u2 {
        assume j; apply âˆ¨áµ¢â‚ j;
      } {
        assume j; apply âˆ¨áµ¢â‚‚ _;
        apply âˆ§â‚‘â‚ (eqn_leq n1 n2) (âˆ§áµ¢ i j);
      };
    };
  } {
    assume h;
    apply âˆ¨â‚‘ h {
      assume i; rewrite i; reflexivity;
    } {
      assume i; rewrite i; reflexivity;
    };
  };
end;

opaque symbol eqn_mul2r m n1 n2 : Ï€ ((n1 * m = n2 * m) â‡” (m = 0) âˆ¨ (n1 = n2)) â‰”
begin
  assume m n1 n2; rewrite mulnC n1 m; rewrite mulnC n2 m;
  refine eqn_mul2l m n1 n2;
end;

opaque symbol leq_pmul2l m n1 n2 :
  Ï€ (istrue (0 < m)) â†’ Ï€ (istrue (m * n1 â‰¤ m * n2) â‡” istrue (n1 â‰¤ n2)) â‰”
begin
  assume m n1 n2 h;
  apply âˆ§áµ¢ {
    assume i;
    have t: Ï€ ((m = 0) âˆ¨ istrue (n1 â‰¤ n2)) { apply âˆ§â‚‘â‚ (leq_mul2l m n1 n2) i; };
    apply âˆ¨â‚‘ t {
      assume j;
      have u: Ï€ (istrue (0 < 0)) { rewrite left .[m in (istrue (_ < m))] j; apply h; };
      refine âŠ¥â‚‘ u;
    } {
      assume j; apply j;
    };
  } {
    assume i; refine âˆ§â‚‘â‚‚ (leq_mul2l m n1 n2) _; refine âˆ¨áµ¢â‚‚ i; 
  };
end;

opaque symbol leq_pmul2r m n1 n2 :
  Ï€ (istrue (0 < m)) â†’ Ï€ (istrue (n1 * m â‰¤ n2 * m) â‡” istrue (n1 â‰¤ n2)) â‰”
begin
  assume m n1 n2 h; rewrite mulnC n1 m; rewrite mulnC n2 m;
  refine leq_pmul2l m n1 n2 h;
end;

opaque symbol ltn0_neq0 m : Ï€ (istrue (0 < m) â‡” m â‰  0) â‰”
begin
  assume m; apply âˆ§áµ¢ {
    generalize m; induction
    { assume h i; apply h; }
    { assume m h i j; apply sâ‰ 0 j;}
  } {
    generalize m; induction
    { assume h; apply h (eq_refl 0); }
    { assume m h i; apply top; }
  };
end;

opaque symbol disj0 m : Ï€ (m = 0 âˆ¨ m â‰  0) â‰”
begin
  induction
  { apply âˆ¨áµ¢â‚ (eq_refl 0); }
  { assume m h; apply âˆ¨áµ¢â‚‚; assume i; apply sâ‰ 0 i; }
end;

opaque symbol eqn_pmul2l m n1 n2 :
  Ï€ (istrue (0 < m)) â†’ Ï€ (m * n1 = m * n2 â‡” n1 = n2) â‰”
begin
  assume m n1 n2 h;
  apply âˆ§áµ¢ {
    assume i1;
    have i2: Ï€ (m * n2 = m * n1) { symmetry; apply i1; };
    have v1: Ï€ (istrue (m * n1 â‰¤ m * n2)) { apply eq_leq _ _ i1; };
    have v2: Ï€ (istrue (m * n2 â‰¤ m * n1)) { apply eq_leq _ _ i2; };
    have w1: Ï€ (istrue (n1 â‰¤ n2)) { apply âˆ§â‚‘â‚ (leq_pmul2l m n1 n2 h) v1 };
    have w2: Ï€ (istrue (n2 â‰¤ n1)) { apply âˆ§â‚‘â‚ (leq_pmul2l m n2 n1 h) v2 };
    apply âˆ§â‚‘â‚ (eqn_leq n1 n2) (âˆ§áµ¢ w1 w2);
  } {
    assume i;
    have t:Ï€ (m = 0 âˆ¨ n1 = n2) { apply âˆ¨áµ¢â‚‚ i; };
    apply âˆ§â‚‘â‚‚ (eqn_mul2l m n1 n2) t;
  };
end;

opaque symbol eqn_pmul2r m n1 n2 :
  Ï€ (istrue (0 < m)) â†’ Ï€ (n1 * m = n2 * m â‡” n1 = n2) â‰”
begin
  assume m n1 n2 h; rewrite mulnC n1 m; rewrite mulnC n2 m;
  apply eqn_pmul2l m n1 n2 h; 
end;

// min

symbol min : â„• â†’ â„• â†’ â„•;

rule min 0 _ â†ª 0
with min _ 0 â†ª 0
with min (s $x) (s $y) â†ª s (min $x $y);

opaque symbol minnC x y : Ï€ (min x y = min y x) â‰”
begin
  induction
  { reflexivity }
  { assume x h; induction
    { reflexivity }
    { assume y i; simplify; rewrite h; reflexivity; }
  }
end;

opaque symbol minnA x y z : Ï€ (min (min x y) z = min x (min y z)) â‰”
begin
  induction
  { reflexivity }
  { assume x h; induction
    { reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; simplify; rewrite h; reflexivity;}
    }
  }
end;

opaque symbol minnAC x y z : Ï€ (min (min x y) z = min (min x z) y) â‰”
begin
  assume x y z; rewrite minnA; rewrite minnC y z; rewrite left minnA;
  reflexivity;
end;

opaque symbol minnCA x y z : Ï€ (min x (min y z) = min y (min x z)) â‰”
begin
  assume x y z; rewrite left minnA; rewrite minnC x y; rewrite minnA;
  reflexivity; 
end;

opaque symbol minnACA x y z t :
  Ï€ (min (min x y) (min z t) = min (min x z) (min y t)) â‰”
begin
  assume x y z t; rewrite minnA; rewrite minnC y (min z t); rewrite minnA;
  rewrite left minnA x z; rewrite minnC t y; reflexivity;
end;

opaque symbol addn_minl x y z: Ï€ ((min y z) + x = min (y + x) (z + x)) â‰”
begin
  induction
  { reflexivity; }
  { assume x h y z; simplify; apply feq s; rewrite h; reflexivity;}
end;

opaque symbol addn_minr x y z: Ï€ (x + (min y z) = min (x + y) (x + z)) â‰”
begin
  induction
  { reflexivity; }
  { assume x h y z; simplify; apply feq s; rewrite h; reflexivity;}
end;

opaque symbol subn_minl x y z: Ï€ ((min x y) - z = min (x - z) (y - z)) â‰”
begin
  induction
  { assume y z; reflexivity; }
  { assume x h; induction
    { assume z; reflexivity; }
    { assume y i; induction
      { reflexivity; }
      { assume z j; simplify; apply h y z; }
    }
  }
end;

opaque symbol minnE m n : Ï€ (min m n = m - (m - n)) â‰”
begin
  induction
  { reflexivity; }
  { assume m h; induction
    { reflexivity; }
    { assume n i; simplify; rewrite h; }
  }
abort;

opaque symbol minnn x : Ï€ (min x x = x) â‰”
begin
  induction
  { reflexivity;}
  { assume x h; simplify; rewrite h; reflexivity; }
end;

rule min $x $x â†ª $x;

opaque symbol geq_minl m n : Ï€ (istrue (min m n â‰¤ m)) â‰”
begin
  induction
  { assume n; apply top; }
  { assume m h; induction
    { apply top; }
    { assume n i; simplify; apply h n; }
  }
end;

opaque symbol geq_minr m n : Ï€ (istrue (min m n â‰¤ n)) â‰”
begin
  assume m n; rewrite minnC; apply geq_minl n m;
end;

// proofs on max and min

opaque symbol addn_min_max m n : Ï€ (min m n + max m n = m + n) â‰”
begin
  induction
  { assume m; reflexivity; }
  { assume m h; induction
    { reflexivity; }
    { assume n i; simplify; rewrite h n; reflexivity; }
  }
end;

opaque symbol maxnK m n : Ï€ (min (max m n) m = m) â‰”
begin
  induction
  { assume n; reflexivity; }
  { assume m h; induction
    { reflexivity; }
    { assume n i; simplify; rewrite h n; reflexivity; }
  }
end;

opaque symbol maxKn m n : Ï€ (min n (max m n) = n) â‰”
begin
  induction
  { assume n; reflexivity; }
  { assume m h; induction
    { reflexivity; }
    { assume n i; simplify; rewrite h n; reflexivity; }
  }
end;

opaque symbol minnK m n : Ï€ (max (min m n) m = m) â‰”
begin
  induction
  { assume n; reflexivity; }
  { assume m h; induction
    { reflexivity; }
    { assume n i; simplify; rewrite h n; reflexivity; }
  }
end;

opaque symbol minKn m n : Ï€ (max n (min m n) = n) â‰”
begin
  induction
  { assume n; reflexivity; }
  { assume m h; induction
    { reflexivity; }
    { assume n i; simplify; rewrite h n; reflexivity; }
  }
end;

opaque symbol maxn_minl x y z : Ï€ (max x (min y z) = min (max x y) (max x z)) â‰”
begin
  induction
  { assume y z; reflexivity; }
  { assume x h; induction
    { assume z; simplify; rewrite minnC; rewrite maxnK (s x) z; reflexivity; }
    { assume y i; induction
      { simplify; rewrite maxnK x y; reflexivity; }
      { assume z j; simplify; rewrite h; reflexivity; }
    }
  }
end;

opaque symbol maxn_minr x y z : Ï€ (max (min y z) x = min (max y x) (max z x)) â‰”
begin
  induction
  { assume y z; reflexivity; }
  { assume x h; induction
    { assume z; simplify; rewrite maxKn z (s x); reflexivity; }
    { assume y i; induction
      { simplify; rewrite maxnC; rewrite maxnK x y; reflexivity; }
      { assume z j; simplify; rewrite h; reflexivity; }
    }
  }
end;

opaque symbol minn_maxl x y z : Ï€ (min x (max y z) = max (min x y) (min x z)) â‰”
begin
  induction
  { assume y z; reflexivity; }
  { assume x h; induction
    { assume z; reflexivity; }
    { assume y i; induction
      { reflexivity; }
      { assume z j; simplify; rewrite h; reflexivity; }
    }
  }
end;

opaque symbol minn_maxr x y z : Ï€ (min (max y z) x = max (min y x) (min z x)) â‰”
begin
  induction
  { assume y z; reflexivity; }
  { assume x h; induction
    { assume z; reflexivity; }
    { assume y i; induction
      { reflexivity; }
      { assume z j; simplify; rewrite h; reflexivity; }
    }
  }
end;

opaque symbol maxnMr x y z : Ï€ ((max y z) * x = max (y * x) (z * x)) â‰”
begin
  induction
  { assume y z; reflexivity; }
  { assume x h; induction
    { assume z; reflexivity; }
    { assume y i; induction
      { reflexivity; }
      { assume z j; rewrite left addn1 y; rewrite left addn1 z; 
        rewrite left addn_maxl 1 y z; symmetry; 
        rewrite mulnDl y 1 (s x); rewrite mulnDl z 1 (s x); 
        rewrite left addn_maxl (1 * s x) (y * s x) (z * s x); rewrite left i; 
        symmetry; rewrite mulnDl (max y z) 1 (s x); reflexivity;
      }
    }
  }
end;

opaque symbol maxnMl x y z : Ï€ (x * (max y z) = max (x * y) (x * z)) â‰”
begin
  induction
  { assume y z; reflexivity; }
  { assume x h; induction
    { assume z; reflexivity; }
    { assume y i; induction
      { reflexivity; }
      { assume z j; rewrite left addn1 y; rewrite left addn1 z; 
        rewrite left addn_maxl 1 y z; symmetry; 
        rewrite mulnDr y 1 (s x); rewrite mulnDr z 1 (s x); 
        rewrite left addn_maxl (s x * 1) (s x * y) (s x * z); rewrite left i; 
        symmetry; rewrite mulnDr (max y z) 1 (s x); reflexivity;
      }
    }
  }
end;

opaque symbol minnMr x y z : Ï€ ((min y z) * x = min (y * x) (z * x)) â‰”
begin
  induction
  { assume y z; reflexivity; }
  { assume x h; induction
    { assume z; reflexivity; }
    { assume y i; induction
      { reflexivity; }
      { assume z j; rewrite left addn1 y; rewrite left addn1 z; 
        rewrite left addn_minl 1 y z; symmetry; 
        rewrite mulnDl y 1 (s x); rewrite mulnDl z 1 (s x); 
        rewrite left addn_minl (1 * s x) (y * s x) (z * s x); rewrite left i; 
        symmetry; rewrite mulnDl (min y z) 1 (s x); reflexivity;
      }
    }
  }
end;

opaque symbol minnMl x y z : Ï€ (x * (min y z) = min (x * y) (x * z)) â‰”
begin
  induction
  { assume y z; reflexivity; }
  { assume x h; induction
    { assume z; reflexivity; }
    { assume y i; induction
      { reflexivity; }
      { assume z j; rewrite left addn1 y; rewrite left addn1 z; 
        rewrite left addn_minl 1 y z; symmetry; 
        rewrite mulnDr y 1 (s x); rewrite mulnDr z 1 (s x); 
        rewrite left addn_minl (s x * 1) (s x * y) (s x * z); rewrite left i; 
        symmetry; rewrite mulnDr (min y z) 1 (s x); reflexivity;
      }
    }
  }
end;

// exponentiation

symbol ^ : â„• â†’ â„• â†’ â„•; notation ^ infix left 40;

rule _ ^ 0 â†ª 1
with $n ^ s $m â†ª $n * $n ^ $m;

opaque symbol expn0 m : Ï€ (m ^ 0 = 1) â‰”
begin
  assume m; reflexivity;
end;

opaque symbol expn m : Ï€ (m ^ 1 = m) â‰”
begin
  assume m; simplify; rewrite mulnS; reflexivity;
end;

opaque symbol expnS a n : Ï€ (a ^ s n = a * a ^ n ) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume n h; reflexivity;}
end;

opaque symbol expnSr a n : Ï€ (a ^ s n = a ^ n * a) â‰”
begin
  assume a n; rewrite expnS a n; rewrite mulnC; reflexivity;
end;

opaque symbol exp0n n : Ï€ (istrue (0 < n)) â†’ Ï€ (0 ^ n = 0) â‰”
begin
  induction
  { assume h; refine âŠ¥â‚‘ h;}
  { assume n h i; reflexivity; }
end;

opaque symbol exp1n n : Ï€ (1 ^ n = 1) â‰”
begin
  induction
  { reflexivity; }
  { assume n h; simplify; rewrite h; reflexivity; }
end;

opaque symbol expnD a m n: Ï€ (a ^ (m + n) = a ^ m * a ^ n) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume m h n; simplify; rewrite h n; rewrite mulnA; reflexivity; }
end;

opaque symbol expnMn m1 m2 n : Ï€ ((m1 * m2) ^ n = m1 ^ n * m2 ^ n) â‰”
begin
  assume m1 m2; induction
  { reflexivity; }
  { assume n h;  simplify; rewrite h; rewrite mulnA; rewrite mulnA;
    rewrite left mulnA (m1 ^ n) m2; rewrite mulnC (m1 ^ n) m2;
    rewrite mulnA m2 (m1 ^ n); reflexivity;
  }
end;

opaque symbol expnM m n1 n2 : Ï€ (m ^ (n1 * n2) = (m ^ n1) ^ n2) â‰”
begin
  assume m; induction
  { assume n2; simplify; rewrite exp1n; reflexivity; }
  { assume n1 h n2; simplify; rewrite expnD; rewrite h n2;
    rewrite left expnMn; reflexivity; }
end;

opaque symbol expnAC m n1 n2 : Ï€ ((m ^ n1) ^ n2 = (m ^ n2) ^ n1) â‰”
begin
  assume m n1 n2; rewrite left expnM; rewrite mulnC; rewrite expnM;
  reflexivity; 
end;

opaque symbol expn_gt0 m n :
  Ï€ ((istrue (0 < m ^ n)) â‡” istrue (0 < m) âˆ¨ (n = 0)) â‰”
begin
  assume m n; apply âˆ§áµ¢ {
    generalize n; induction
    { assume h; apply âˆ¨áµ¢â‚‚ (eq_refl 0); }
    { assume n h i;
      have t: Ï€ (istrue (0 < m ^ n)) { };
    }
  } {
  };
abort;

opaque symbol ltn_expl m n : Ï€ (istrue (1 < m)) â†’ Ï€ (istrue (n < m ^ n)) â‰”
begin
  assume m; induction
  { assume h; apply top; }
  { assume n h i; 
    have t: Ï€ (istrue (n < (m ^ n))) { apply h i; };
    rewrite expnS; 
  }
abort;

// factorial

symbol ! : â„• â†’ â„•; notation ! postfix 40;

rule 0 ! â†ª 1
with (s $n) ! â†ª (s $n) * $n !;

opaque symbol fact0 : Ï€ (0 ! = 1) â‰”
begin
  reflexivity;
end;

opaque symbol factS n : Ï€ ((s n) ! = s n * n !) â‰”
begin
  reflexivity; 
end;

opaque symbol fact_gt0 n : Ï€ (istrue (n ! > 0)) â‰”
begin
  induction
  { apply top; }
  { assume n h; rewrite factS n; rewrite mulSnr n (n !);
    apply ltn_addl 0 (n !) (n * n !); apply h; }
end;

opaque symbol fact_gt1 n : Ï€ (istrue (n ! â‰¥ 1)) â‰”
begin
  refine fact_gt0;
end;

opaque symbol fact_geq n : Ï€ (istrue (n â‰¤ n !)) â‰”
begin
  induction
  { apply top; }
  { assume n h; rewrite factS n; apply leq_pmulr (s n) (n !) (fact_gt0 n); }
end;
