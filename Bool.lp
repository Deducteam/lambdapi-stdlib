/* Library on booleans. */

require open Blanqui.Lib.Set Blanqui.Lib.Prop Blanqui.Lib.FOL Blanqui.Lib.Eq;

inductive ğ”¹ : TYPE â‰” // `dB or \BbbB
| true : ğ”¹
| false : ğ”¹;

constant symbol bool : Set;

rule Ï„ bool â†ª ğ”¹;

// induction principle with equalities

opaque symbol case_ğ”¹ b : Ï€ (b = true âˆ¨ b = false) â‰”
begin
  induction
  { apply âˆ¨áµ¢â‚; reflexivity; }
  { apply âˆ¨áµ¢â‚‚; reflexivity; }
end;

opaque symbol ind_ğ”¹_eq p b:
 (Ï€(b = true) â†’ Ï€(p b)) â†’ (Ï€(b = false) â†’ Ï€(p b)) â†’ Ï€(p b) â‰”
begin
  assume p b t f; refine âˆ¨â‚‘ (case_ğ”¹ b) t f;
end;

// non confusion of constructors

symbol istrue : ğ”¹ â†’ Prop;

rule istrue true â†ª âŠ¤
with istrue false â†ª âŠ¥;

opaque symbol falseâ‰ true : Ï€ (false â‰  true) â‰”
begin
  assume h; refine ind_eq h istrue top
end;

opaque symbol trueâ‰ false : Ï€ (true â‰  false) â‰”
begin
  assume h; apply falseâ‰ true; symmetry; apply h
end;

// not

symbol not : ğ”¹ â†’ ğ”¹;

rule not true  â†ª false
with not false â†ª true;

// or

symbol or : ğ”¹ â†’ ğ”¹ â†’ ğ”¹; notation or infix left 20;

rule true  or _     â†ª true
with _     or true  â†ª true
with false or $b    â†ª $b
with $b    or false â†ª $b;

opaque symbol âˆ¨_istrue [p q] : Ï€(istrue(p or q)) â†’ Ï€(istrue p âˆ¨ istrue q) â‰”
begin
  induction
  { assume q h; apply âˆ¨áµ¢â‚; apply top; }
  { assume q h; apply âˆ¨áµ¢â‚‚; apply h; }
end;

opaque symbol istrue_or [p q] : Ï€(istrue p âˆ¨ istrue q) â†’ Ï€(istrue(p or q)) â‰”
begin
  induction
  { assume q h; apply top; }
  { assume q h; apply âˆ¨â‚‘ h { assume i; apply âŠ¥â‚‘ i; } { assume i; apply i; } }
end;

opaque symbol oráµ¢â‚ [p] q : Ï€ (istrue p) â†’ Ï€ (istrue (p or q)) â‰”
begin
  induction
  { simplify; assume b h; apply top }
  { simplify; assume b h; apply âŠ¥â‚‘ h }
end;

opaque symbol oráµ¢â‚‚ p [q] : Ï€ (istrue q) â†’ Ï€ (istrue (p or q)) â‰”
begin
  induction
  { simplify; assume b h; apply top }
  { simplify; assume b h; apply h }
end;

opaque symbol orâ‚‘ [p q] r : Ï€(istrue(p or q)) â†’
  (Ï€(istrue p) â†’ Ï€(istrue r)) â†’ (Ï€(istrue q) â†’ Ï€(istrue r)) â†’ Ï€(istrue r) â‰”
begin
  assume p q r pq pr qr;
  have h: Ï€(istrue p âˆ¨ istrue q) { apply @âˆ¨_istrue p q pq /*FIXME*/ };
  apply âˆ¨â‚‘ h pr qr;
end;

opaque symbol orC p q : Ï€ (p or q = q or p) â‰”
begin
    induction
    { reflexivity; }
    { reflexivity; }
end;

opaque symbol orA p q r : Ï€ ((p or q) or r = p or (q or r)) â‰”
begin
    induction
    { reflexivity; }
    { reflexivity; }
end;

// and

symbol and : ğ”¹ â†’ ğ”¹ â†’ ğ”¹; notation and infix left 7;

rule true  and $b    â†ª $b
with $b    and true  â†ª $b
with false and _     â†ª false
with _     and false â†ª false;

opaque symbol âˆ§_istrue [p q] : Ï€(istrue (p and q)) â†’ Ï€(istrue p âˆ§ istrue q) â‰”
begin
  induction
  { induction
    { assume h; apply âˆ§áµ¢ { apply top } { apply top } }
    { assume h; apply âŠ¥â‚‘ h; }
  }
  { assume q h; apply âŠ¥â‚‘ h; }
end;

opaque symbol istrue_and [p q] : Ï€(istrue p âˆ§ istrue q) â†’ Ï€(istrue (p and q)) â‰”
begin
  induction
  { assume q h; apply âˆ§â‚‘â‚‚ h; }
  { assume q h; apply âˆ§â‚‘â‚ h; }
end;

opaque symbol andáµ¢ [p q] : Ï€(istrue p) â†’ Ï€(istrue q) â†’ Ï€(istrue (p and q)) â‰”
begin
  assume p q h i; //FIXME: apply istrue_and fails
  apply @istrue_and p q; apply âˆ§áµ¢ h i;
end;

opaque symbol andâ‚‘â‚ [p q] : Ï€ (istrue (p and q)) â†’ Ï€ (istrue p) â‰”
begin
  induction
  { assume q i; apply top; }
  { assume q i; apply i; }
end;

opaque symbol andâ‚‘â‚‚ [p q] : Ï€ (istrue (p and q)) â†’ Ï€ (istrue q) â‰”
begin
  induction
  { assume q i; apply i; }
  { assume q i; apply âŠ¥â‚‘ i; }
end;

// if-then-else

symbol if : ğ”¹ â†’ Î  [a], Ï„ a â†’ Ï„ a â†’ Ï„ a;

rule if true  $x _ â†ª $x
with if false _ $y â†ª $y;

