// Booleans

require open Blanqui.Lib.Set Blanqui.Lib.Prop Blanqui.Lib.FOL Blanqui.Lib.Eq;

inductive ğ”¹ : TYPE â‰”
| true : ğ”¹
| false : ğ”¹;

// set code for ğ”¹

constant symbol bool : Set;

rule Ï„ bool â†ª ğ”¹;

//Some useful predicates
symbol istrue : ğ”¹ â†’ Prop;

rule istrue true â†ª âŠ¤
with istrue false â†ª âŠ¥;

symbol boolification : Prop â†’ ğ”¹;

rule boolification âŠ¤ â†ª true
with boolification âŠ¥ â†ª false;

// ğ”¹oolean not

symbol not : ğ”¹ â†’ ğ”¹;

rule not true  â†ª false
with not false â†ª true;

// ğ”¹oolean or

symbol or : ğ”¹ â†’ ğ”¹ â†’ ğ”¹;

notation or infix left 6;

rule true  or _     â†ª true
with _     or true  â†ª true
with false or $b    â†ª $b
with $b    or false â†ª $b;

symbol or_i1 p q : Ï€ (istrue p) â†’ Ï€ (istrue (p or q));
symbol or_i2 p q : Ï€ (istrue q) â†’ Ï€ (istrue (p or q));

opaque symbol orC p q : Ï€ ((p or q) = (q or p)) â‰”
begin
    induction
    { reflexivity; }
    { reflexivity; }
end;

opaque symbol orA p q r : Ï€ (((p or q) or r) = (p or (q or r))) â‰”
begin
    induction
    { reflexivity; }
    { reflexivity; }
end;

// ğ”¹oolean and

symbol and : ğ”¹ â†’ ğ”¹ â†’ ğ”¹;

notation and infix left 7;

rule true  and $b    â†ª $b
with $b    and true  â†ª $b
with false and _     â†ª false
with _     and false â†ª false;

symbol and_e1 p q : Ï€ (istrue (p and q)) â†’ Ï€ (istrue p); 
symbol and_e2 p q : Ï€ (istrue (p and q)) â†’ Ï€ (istrue q); 

// Conditional

symbol if : ğ”¹ â†’ Î  [a], Ï„ a â†’ Ï„ a â†’ Ï„ a;

rule if true  $x _ â†ª $x
with if false _ $y â†ª $y;

// Induction principle with hypothesis

opaque symbol dis_B : Î  b:ğ”¹, Ï€ (b = true âˆ¨ b = false) â‰”
begin
  induction
  { apply âˆ¨áµ¢â‚ (true = true) (true = false); reflexivity; }
  { apply âˆ¨áµ¢â‚‚ (false = true) (false = false); reflexivity; }
end;

opaque symbol ind_B : Î  P:(ğ”¹ â†’ Prop), Î  b:ğ”¹, (Ï€ (b = true) â†’ Ï€ (P b)) â†’ (Ï€ (b = false) â†’ Ï€ (P b)) â†’ Ï€ (P b) â‰”
begin
  assume P b ht hf;
  refine âˆ¨â‚‘ (b = true) (b = false) (P b) (dis_B b) ht hf;
end;